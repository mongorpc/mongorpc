// Copyright 2024 MongoRPC
// SPDX-License-Identifier: Apache-2.0
//
// Write operation definitions for MongoRPC.
// This file defines insert, update, delete, and bulk write operations.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: mongorpc/v1/write.proto

package mongorpcv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The type of date value.
type CurrentDateSpec_DateType int32

const (
	// Default timestamp type.
	CurrentDateSpec_DATE_TYPE_UNSPECIFIED CurrentDateSpec_DateType = 0
	// BSON Date type.
	CurrentDateSpec_DATE CurrentDateSpec_DateType = 1
	// BSON Timestamp type.
	CurrentDateSpec_TIMESTAMP CurrentDateSpec_DateType = 2
)

// Enum value maps for CurrentDateSpec_DateType.
var (
	CurrentDateSpec_DateType_name = map[int32]string{
		0: "DATE_TYPE_UNSPECIFIED",
		1: "DATE",
		2: "TIMESTAMP",
	}
	CurrentDateSpec_DateType_value = map[string]int32{
		"DATE_TYPE_UNSPECIFIED": 0,
		"DATE":                  1,
		"TIMESTAMP":             2,
	}
)

func (x CurrentDateSpec_DateType) Enum() *CurrentDateSpec_DateType {
	p := new(CurrentDateSpec_DateType)
	*p = x
	return p
}

func (x CurrentDateSpec_DateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CurrentDateSpec_DateType) Descriptor() protoreflect.EnumDescriptor {
	return file_mongorpc_v1_write_proto_enumTypes[0].Descriptor()
}

func (CurrentDateSpec_DateType) Type() protoreflect.EnumType {
	return &file_mongorpc_v1_write_proto_enumTypes[0]
}

func (x CurrentDateSpec_DateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CurrentDateSpec_DateType.Descriptor instead.
func (CurrentDateSpec_DateType) EnumDescriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{5, 0}
}

// A write operation on a document.
type Write struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The database for this operation.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// The collection for this operation.
	Collection string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
	// The operation to execute.
	//
	// Types that are valid to be assigned to Operation:
	//
	//	*Write_Insert
	//	*Write_Update
	//	*Write_Delete
	//	*Write_Replace
	Operation isWrite_Operation `protobuf_oneof:"operation"`
	// Optional precondition for the write.
	Precondition  *Precondition `protobuf:"bytes,7,opt,name=precondition,proto3" json:"precondition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Write) Reset() {
	*x = Write{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Write) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Write) ProtoMessage() {}

func (x *Write) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Write.ProtoReflect.Descriptor instead.
func (*Write) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{0}
}

func (x *Write) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *Write) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *Write) GetOperation() isWrite_Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *Write) GetInsert() *InsertOperation {
	if x != nil {
		if x, ok := x.Operation.(*Write_Insert); ok {
			return x.Insert
		}
	}
	return nil
}

func (x *Write) GetUpdate() *UpdateOperation {
	if x != nil {
		if x, ok := x.Operation.(*Write_Update); ok {
			return x.Update
		}
	}
	return nil
}

func (x *Write) GetDelete() *DeleteOperation {
	if x != nil {
		if x, ok := x.Operation.(*Write_Delete); ok {
			return x.Delete
		}
	}
	return nil
}

func (x *Write) GetReplace() *ReplaceOperation {
	if x != nil {
		if x, ok := x.Operation.(*Write_Replace); ok {
			return x.Replace
		}
	}
	return nil
}

func (x *Write) GetPrecondition() *Precondition {
	if x != nil {
		return x.Precondition
	}
	return nil
}

type isWrite_Operation interface {
	isWrite_Operation()
}

type Write_Insert struct {
	// Insert a new document.
	Insert *InsertOperation `protobuf:"bytes,3,opt,name=insert,proto3,oneof"`
}

type Write_Update struct {
	// Update existing document(s).
	Update *UpdateOperation `protobuf:"bytes,4,opt,name=update,proto3,oneof"`
}

type Write_Delete struct {
	// Delete document(s).
	Delete *DeleteOperation `protobuf:"bytes,5,opt,name=delete,proto3,oneof"`
}

type Write_Replace struct {
	// Replace a document.
	Replace *ReplaceOperation `protobuf:"bytes,6,opt,name=replace,proto3,oneof"`
}

func (*Write_Insert) isWrite_Operation() {}

func (*Write_Update) isWrite_Operation() {}

func (*Write_Delete) isWrite_Operation() {}

func (*Write_Replace) isWrite_Operation() {}

// Insert operation.
type InsertOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The document to insert.
	// If _id is not provided, one will be generated.
	Document      *Document `protobuf:"bytes,1,opt,name=document,proto3" json:"document,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InsertOperation) Reset() {
	*x = InsertOperation{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InsertOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InsertOperation) ProtoMessage() {}

func (x *InsertOperation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InsertOperation.ProtoReflect.Descriptor instead.
func (*InsertOperation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{1}
}

func (x *InsertOperation) GetDocument() *Document {
	if x != nil {
		return x.Document
	}
	return nil
}

// Update operation.
type UpdateOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The filter to select documents to update.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// The update specification.
	Update *UpdateSpec `protobuf:"bytes,2,opt,name=update,proto3" json:"update,omitempty"`
	// Whether to update multiple documents (default: false = update one).
	Multi bool `protobuf:"varint,3,opt,name=multi,proto3" json:"multi,omitempty"`
	// Whether to insert if no documents match (upsert).
	Upsert bool `protobuf:"varint,4,opt,name=upsert,proto3" json:"upsert,omitempty"`
	// Array filters for positional array updates.
	ArrayFilters []*MapValue `protobuf:"bytes,5,rep,name=array_filters,json=arrayFilters,proto3" json:"array_filters,omitempty"`
	// Collation for string comparison.
	Collation *Collation `protobuf:"bytes,6,opt,name=collation,proto3" json:"collation,omitempty"`
	// Hint for index usage.
	Hint          *IndexHint `protobuf:"bytes,7,opt,name=hint,proto3" json:"hint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOperation) Reset() {
	*x = UpdateOperation{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOperation) ProtoMessage() {}

func (x *UpdateOperation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOperation.ProtoReflect.Descriptor instead.
func (*UpdateOperation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{2}
}

func (x *UpdateOperation) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *UpdateOperation) GetUpdate() *UpdateSpec {
	if x != nil {
		return x.Update
	}
	return nil
}

func (x *UpdateOperation) GetMulti() bool {
	if x != nil {
		return x.Multi
	}
	return false
}

func (x *UpdateOperation) GetUpsert() bool {
	if x != nil {
		return x.Upsert
	}
	return false
}

func (x *UpdateOperation) GetArrayFilters() []*MapValue {
	if x != nil {
		return x.ArrayFilters
	}
	return nil
}

func (x *UpdateOperation) GetCollation() *Collation {
	if x != nil {
		return x.Collation
	}
	return nil
}

func (x *UpdateOperation) GetHint() *IndexHint {
	if x != nil {
		return x.Hint
	}
	return nil
}

// Update specification.
type UpdateSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of update.
	//
	// Types that are valid to be assigned to UpdateType:
	//
	//	*UpdateSpec_Operators
	//	*UpdateSpec_Pipeline
	UpdateType    isUpdateSpec_UpdateType `protobuf_oneof:"update_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateSpec) Reset() {
	*x = UpdateSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateSpec) ProtoMessage() {}

func (x *UpdateSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateSpec.ProtoReflect.Descriptor instead.
func (*UpdateSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{3}
}

func (x *UpdateSpec) GetUpdateType() isUpdateSpec_UpdateType {
	if x != nil {
		return x.UpdateType
	}
	return nil
}

func (x *UpdateSpec) GetOperators() *UpdateOperators {
	if x != nil {
		if x, ok := x.UpdateType.(*UpdateSpec_Operators); ok {
			return x.Operators
		}
	}
	return nil
}

func (x *UpdateSpec) GetPipeline() *AggregationUpdate {
	if x != nil {
		if x, ok := x.UpdateType.(*UpdateSpec_Pipeline); ok {
			return x.Pipeline
		}
	}
	return nil
}

type isUpdateSpec_UpdateType interface {
	isUpdateSpec_UpdateType()
}

type UpdateSpec_Operators struct {
	// Update operators ($set, $inc, etc.).
	Operators *UpdateOperators `protobuf:"bytes,1,opt,name=operators,proto3,oneof"`
}

type UpdateSpec_Pipeline struct {
	// Aggregation pipeline for updates (MongoDB 4.2+).
	Pipeline *AggregationUpdate `protobuf:"bytes,2,opt,name=pipeline,proto3,oneof"`
}

func (*UpdateSpec_Operators) isUpdateSpec_UpdateType() {}

func (*UpdateSpec_Pipeline) isUpdateSpec_UpdateType() {}

// Update using standard MongoDB operators.
type UpdateOperators struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// $set - Set field values.
	Set map[string]*Value `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $unset - Remove fields.
	Unset []string `protobuf:"bytes,2,rep,name=unset,proto3" json:"unset,omitempty"`
	// $inc - Increment numeric fields.
	Inc map[string]*Value `protobuf:"bytes,3,rep,name=inc,proto3" json:"inc,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $mul - Multiply numeric fields.
	Mul map[string]*Value `protobuf:"bytes,4,rep,name=mul,proto3" json:"mul,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $min - Update if new value is less than current.
	Min map[string]*Value `protobuf:"bytes,5,rep,name=min,proto3" json:"min,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $max - Update if new value is greater than current.
	Max map[string]*Value `protobuf:"bytes,6,rep,name=max,proto3" json:"max,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $rename - Rename fields.
	Rename map[string]string `protobuf:"bytes,7,rep,name=rename,proto3" json:"rename,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// $currentDate - Set to current date.
	CurrentDate []*CurrentDateSpec `protobuf:"bytes,8,rep,name=current_date,json=currentDate,proto3" json:"current_date,omitempty"`
	// $setOnInsert - Set only on insert (upsert).
	SetOnInsert map[string]*Value `protobuf:"bytes,9,rep,name=set_on_insert,json=setOnInsert,proto3" json:"set_on_insert,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Array update operators.
	Array *ArrayUpdateOperators `protobuf:"bytes,10,opt,name=array,proto3" json:"array,omitempty"`
	// Bitwise update operators.
	Bitwise       *BitwiseUpdateOperators `protobuf:"bytes,11,opt,name=bitwise,proto3" json:"bitwise,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOperators) Reset() {
	*x = UpdateOperators{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOperators) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOperators) ProtoMessage() {}

func (x *UpdateOperators) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOperators.ProtoReflect.Descriptor instead.
func (*UpdateOperators) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{4}
}

func (x *UpdateOperators) GetSet() map[string]*Value {
	if x != nil {
		return x.Set
	}
	return nil
}

func (x *UpdateOperators) GetUnset() []string {
	if x != nil {
		return x.Unset
	}
	return nil
}

func (x *UpdateOperators) GetInc() map[string]*Value {
	if x != nil {
		return x.Inc
	}
	return nil
}

func (x *UpdateOperators) GetMul() map[string]*Value {
	if x != nil {
		return x.Mul
	}
	return nil
}

func (x *UpdateOperators) GetMin() map[string]*Value {
	if x != nil {
		return x.Min
	}
	return nil
}

func (x *UpdateOperators) GetMax() map[string]*Value {
	if x != nil {
		return x.Max
	}
	return nil
}

func (x *UpdateOperators) GetRename() map[string]string {
	if x != nil {
		return x.Rename
	}
	return nil
}

func (x *UpdateOperators) GetCurrentDate() []*CurrentDateSpec {
	if x != nil {
		return x.CurrentDate
	}
	return nil
}

func (x *UpdateOperators) GetSetOnInsert() map[string]*Value {
	if x != nil {
		return x.SetOnInsert
	}
	return nil
}

func (x *UpdateOperators) GetArray() *ArrayUpdateOperators {
	if x != nil {
		return x.Array
	}
	return nil
}

func (x *UpdateOperators) GetBitwise() *BitwiseUpdateOperators {
	if x != nil {
		return x.Bitwise
	}
	return nil
}

// Specification for $currentDate operator.
type CurrentDateSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field to update.
	Field         string                   `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Type          CurrentDateSpec_DateType `protobuf:"varint,2,opt,name=type,proto3,enum=mongorpc.v1.CurrentDateSpec_DateType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CurrentDateSpec) Reset() {
	*x = CurrentDateSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CurrentDateSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CurrentDateSpec) ProtoMessage() {}

func (x *CurrentDateSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CurrentDateSpec.ProtoReflect.Descriptor instead.
func (*CurrentDateSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{5}
}

func (x *CurrentDateSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *CurrentDateSpec) GetType() CurrentDateSpec_DateType {
	if x != nil {
		return x.Type
	}
	return CurrentDateSpec_DATE_TYPE_UNSPECIFIED
}

// Array update operators.
type ArrayUpdateOperators struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// $push - Add elements to array.
	Push []*ArrayPushSpec `protobuf:"bytes,1,rep,name=push,proto3" json:"push,omitempty"`
	// $addToSet - Add unique elements to array.
	AddToSet []*ArrayAddToSetSpec `protobuf:"bytes,2,rep,name=add_to_set,json=addToSet,proto3" json:"add_to_set,omitempty"`
	// $pop - Remove first or last element.
	Pop []*ArrayPopSpec `protobuf:"bytes,3,rep,name=pop,proto3" json:"pop,omitempty"`
	// $pull - Remove elements matching condition.
	Pull []*ArrayPullSpec `protobuf:"bytes,4,rep,name=pull,proto3" json:"pull,omitempty"`
	// $pullAll - Remove all matching elements.
	PullAll []*ArrayPullAllSpec `protobuf:"bytes,5,rep,name=pull_all,json=pullAll,proto3" json:"pull_all,omitempty"`
	// Positional updates ($, $[], $[<identifier>]).
	Positional    []*PositionalUpdate `protobuf:"bytes,6,rep,name=positional,proto3" json:"positional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayUpdateOperators) Reset() {
	*x = ArrayUpdateOperators{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayUpdateOperators) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayUpdateOperators) ProtoMessage() {}

func (x *ArrayUpdateOperators) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayUpdateOperators.ProtoReflect.Descriptor instead.
func (*ArrayUpdateOperators) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{6}
}

func (x *ArrayUpdateOperators) GetPush() []*ArrayPushSpec {
	if x != nil {
		return x.Push
	}
	return nil
}

func (x *ArrayUpdateOperators) GetAddToSet() []*ArrayAddToSetSpec {
	if x != nil {
		return x.AddToSet
	}
	return nil
}

func (x *ArrayUpdateOperators) GetPop() []*ArrayPopSpec {
	if x != nil {
		return x.Pop
	}
	return nil
}

func (x *ArrayUpdateOperators) GetPull() []*ArrayPullSpec {
	if x != nil {
		return x.Pull
	}
	return nil
}

func (x *ArrayUpdateOperators) GetPullAll() []*ArrayPullAllSpec {
	if x != nil {
		return x.PullAll
	}
	return nil
}

func (x *ArrayUpdateOperators) GetPositional() []*PositionalUpdate {
	if x != nil {
		return x.Positional
	}
	return nil
}

// $push specification.
type ArrayPushSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The value(s) to push.
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Push multiple values with $each.
	Each []*Value `protobuf:"bytes,3,rep,name=each,proto3" json:"each,omitempty"`
	// Sort the array after push.
	Sort []*SortOrder `protobuf:"bytes,4,rep,name=sort,proto3" json:"sort,omitempty"`
	// Limit array size after push.
	Slice int32 `protobuf:"varint,5,opt,name=slice,proto3" json:"slice,omitempty"`
	// Position to insert at.
	Position      int32 `protobuf:"varint,6,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayPushSpec) Reset() {
	*x = ArrayPushSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayPushSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayPushSpec) ProtoMessage() {}

func (x *ArrayPushSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayPushSpec.ProtoReflect.Descriptor instead.
func (*ArrayPushSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{7}
}

func (x *ArrayPushSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ArrayPushSpec) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ArrayPushSpec) GetEach() []*Value {
	if x != nil {
		return x.Each
	}
	return nil
}

func (x *ArrayPushSpec) GetSort() []*SortOrder {
	if x != nil {
		return x.Sort
	}
	return nil
}

func (x *ArrayPushSpec) GetSlice() int32 {
	if x != nil {
		return x.Slice
	}
	return 0
}

func (x *ArrayPushSpec) GetPosition() int32 {
	if x != nil {
		return x.Position
	}
	return 0
}

// $addToSet specification.
type ArrayAddToSetSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The value to add.
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Add multiple values with $each.
	Each          []*Value `protobuf:"bytes,3,rep,name=each,proto3" json:"each,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayAddToSetSpec) Reset() {
	*x = ArrayAddToSetSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayAddToSetSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayAddToSetSpec) ProtoMessage() {}

func (x *ArrayAddToSetSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayAddToSetSpec.ProtoReflect.Descriptor instead.
func (*ArrayAddToSetSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{8}
}

func (x *ArrayAddToSetSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ArrayAddToSetSpec) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ArrayAddToSetSpec) GetEach() []*Value {
	if x != nil {
		return x.Each
	}
	return nil
}

// $pop specification.
type ArrayPopSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// -1 for first, 1 for last.
	Position      int32 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayPopSpec) Reset() {
	*x = ArrayPopSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayPopSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayPopSpec) ProtoMessage() {}

func (x *ArrayPopSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayPopSpec.ProtoReflect.Descriptor instead.
func (*ArrayPopSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{9}
}

func (x *ArrayPopSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ArrayPopSpec) GetPosition() int32 {
	if x != nil {
		return x.Position
	}
	return 0
}

// $pull specification.
type ArrayPullSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The condition or value to match.
	Condition     *Value `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayPullSpec) Reset() {
	*x = ArrayPullSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayPullSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayPullSpec) ProtoMessage() {}

func (x *ArrayPullSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayPullSpec.ProtoReflect.Descriptor instead.
func (*ArrayPullSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{10}
}

func (x *ArrayPullSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ArrayPullSpec) GetCondition() *Value {
	if x != nil {
		return x.Condition
	}
	return nil
}

// $pullAll specification.
type ArrayPullAllSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The values to remove.
	Values        []*Value `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArrayPullAllSpec) Reset() {
	*x = ArrayPullAllSpec{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArrayPullAllSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArrayPullAllSpec) ProtoMessage() {}

func (x *ArrayPullAllSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArrayPullAllSpec.ProtoReflect.Descriptor instead.
func (*ArrayPullAllSpec) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{11}
}

func (x *ArrayPullAllSpec) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ArrayPullAllSpec) GetValues() []*Value {
	if x != nil {
		return x.Values
	}
	return nil
}

// Positional array update.
type PositionalUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field path with positional operator.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The value to set.
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The identifier for $[<identifier>] syntax.
	Identifier    string `protobuf:"bytes,3,opt,name=identifier,proto3" json:"identifier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PositionalUpdate) Reset() {
	*x = PositionalUpdate{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PositionalUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PositionalUpdate) ProtoMessage() {}

func (x *PositionalUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PositionalUpdate.ProtoReflect.Descriptor instead.
func (*PositionalUpdate) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{12}
}

func (x *PositionalUpdate) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *PositionalUpdate) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PositionalUpdate) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

// Bitwise update operators.
type BitwiseUpdateOperators struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bitwise AND.
	And map[string]int64 `protobuf:"bytes,1,rep,name=and,proto3" json:"and,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Bitwise OR.
	Or map[string]int64 `protobuf:"bytes,2,rep,name=or,proto3" json:"or,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Bitwise XOR.
	Xor           map[string]int64 `protobuf:"bytes,3,rep,name=xor,proto3" json:"xor,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitwiseUpdateOperators) Reset() {
	*x = BitwiseUpdateOperators{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitwiseUpdateOperators) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitwiseUpdateOperators) ProtoMessage() {}

func (x *BitwiseUpdateOperators) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitwiseUpdateOperators.ProtoReflect.Descriptor instead.
func (*BitwiseUpdateOperators) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{13}
}

func (x *BitwiseUpdateOperators) GetAnd() map[string]int64 {
	if x != nil {
		return x.And
	}
	return nil
}

func (x *BitwiseUpdateOperators) GetOr() map[string]int64 {
	if x != nil {
		return x.Or
	}
	return nil
}

func (x *BitwiseUpdateOperators) GetXor() map[string]int64 {
	if x != nil {
		return x.Xor
	}
	return nil
}

// Aggregation-based update (MongoDB 4.2+).
type AggregationUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The aggregation pipeline stages.
	// Only certain stages are allowed: $addFields, $set, $project, $unset, $replaceRoot, $replaceWith.
	Stages        []*MapValue `protobuf:"bytes,1,rep,name=stages,proto3" json:"stages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregationUpdate) Reset() {
	*x = AggregationUpdate{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationUpdate) ProtoMessage() {}

func (x *AggregationUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationUpdate.ProtoReflect.Descriptor instead.
func (*AggregationUpdate) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{14}
}

func (x *AggregationUpdate) GetStages() []*MapValue {
	if x != nil {
		return x.Stages
	}
	return nil
}

// Delete operation.
type DeleteOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The filter to select documents to delete.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// Whether to delete multiple documents (default: false = delete one).
	Multi bool `protobuf:"varint,2,opt,name=multi,proto3" json:"multi,omitempty"`
	// Collation for string comparison.
	Collation *Collation `protobuf:"bytes,3,opt,name=collation,proto3" json:"collation,omitempty"`
	// Hint for index usage.
	Hint          *IndexHint `protobuf:"bytes,4,opt,name=hint,proto3" json:"hint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteOperation) Reset() {
	*x = DeleteOperation{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteOperation) ProtoMessage() {}

func (x *DeleteOperation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteOperation.ProtoReflect.Descriptor instead.
func (*DeleteOperation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{15}
}

func (x *DeleteOperation) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *DeleteOperation) GetMulti() bool {
	if x != nil {
		return x.Multi
	}
	return false
}

func (x *DeleteOperation) GetCollation() *Collation {
	if x != nil {
		return x.Collation
	}
	return nil
}

func (x *DeleteOperation) GetHint() *IndexHint {
	if x != nil {
		return x.Hint
	}
	return nil
}

// Replace operation (full document replacement).
type ReplaceOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The filter to select the document to replace.
	Filter *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// The replacement document.
	Replacement *Document `protobuf:"bytes,2,opt,name=replacement,proto3" json:"replacement,omitempty"`
	// Whether to insert if no documents match (upsert).
	Upsert bool `protobuf:"varint,3,opt,name=upsert,proto3" json:"upsert,omitempty"`
	// Collation for string comparison.
	Collation *Collation `protobuf:"bytes,4,opt,name=collation,proto3" json:"collation,omitempty"`
	// Hint for index usage.
	Hint          *IndexHint `protobuf:"bytes,5,opt,name=hint,proto3" json:"hint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplaceOperation) Reset() {
	*x = ReplaceOperation{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplaceOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceOperation) ProtoMessage() {}

func (x *ReplaceOperation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceOperation.ProtoReflect.Descriptor instead.
func (*ReplaceOperation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{16}
}

func (x *ReplaceOperation) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *ReplaceOperation) GetReplacement() *Document {
	if x != nil {
		return x.Replacement
	}
	return nil
}

func (x *ReplaceOperation) GetUpsert() bool {
	if x != nil {
		return x.Upsert
	}
	return false
}

func (x *ReplaceOperation) GetCollation() *Collation {
	if x != nil {
		return x.Collation
	}
	return nil
}

func (x *ReplaceOperation) GetHint() *IndexHint {
	if x != nil {
		return x.Hint
	}
	return nil
}

// Result of a write operation.
type WriteResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of documents matched.
	MatchedCount int64 `protobuf:"varint,1,opt,name=matched_count,json=matchedCount,proto3" json:"matched_count,omitempty"`
	// The number of documents modified.
	ModifiedCount int64 `protobuf:"varint,2,opt,name=modified_count,json=modifiedCount,proto3" json:"modified_count,omitempty"`
	// The number of documents inserted.
	InsertedCount int64 `protobuf:"varint,3,opt,name=inserted_count,json=insertedCount,proto3" json:"inserted_count,omitempty"`
	// The number of documents deleted.
	DeletedCount int64 `protobuf:"varint,4,opt,name=deleted_count,json=deletedCount,proto3" json:"deleted_count,omitempty"`
	// The ID of the upserted document (if any).
	UpsertedId *ObjectId `protobuf:"bytes,5,opt,name=upserted_id,json=upsertedId,proto3" json:"upserted_id,omitempty"`
	// The time at which the write occurred.
	WriteTime     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=write_time,json=writeTime,proto3" json:"write_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WriteResult) Reset() {
	*x = WriteResult{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WriteResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WriteResult) ProtoMessage() {}

func (x *WriteResult) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WriteResult.ProtoReflect.Descriptor instead.
func (*WriteResult) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{17}
}

func (x *WriteResult) GetMatchedCount() int64 {
	if x != nil {
		return x.MatchedCount
	}
	return 0
}

func (x *WriteResult) GetModifiedCount() int64 {
	if x != nil {
		return x.ModifiedCount
	}
	return 0
}

func (x *WriteResult) GetInsertedCount() int64 {
	if x != nil {
		return x.InsertedCount
	}
	return 0
}

func (x *WriteResult) GetDeletedCount() int64 {
	if x != nil {
		return x.DeletedCount
	}
	return 0
}

func (x *WriteResult) GetUpsertedId() *ObjectId {
	if x != nil {
		return x.UpsertedId
	}
	return nil
}

func (x *WriteResult) GetWriteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WriteTime
	}
	return nil
}

// Bulk write operations.
type BulkWrite struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The database for all operations.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// The collection for all operations.
	Collection string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
	// The operations to execute.
	Operations []*BulkWriteOperation `protobuf:"bytes,3,rep,name=operations,proto3" json:"operations,omitempty"`
	// Whether operations should be executed in order.
	Ordered bool `protobuf:"varint,4,opt,name=ordered,proto3" json:"ordered,omitempty"`
	// Whether to bypass document validation.
	BypassDocumentValidation bool `protobuf:"varint,5,opt,name=bypass_document_validation,json=bypassDocumentValidation,proto3" json:"bypass_document_validation,omitempty"`
	// Write concern.
	WriteConcern  *WriteConcern `protobuf:"bytes,6,opt,name=write_concern,json=writeConcern,proto3" json:"write_concern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkWrite) Reset() {
	*x = BulkWrite{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkWrite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkWrite) ProtoMessage() {}

func (x *BulkWrite) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkWrite.ProtoReflect.Descriptor instead.
func (*BulkWrite) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{18}
}

func (x *BulkWrite) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *BulkWrite) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *BulkWrite) GetOperations() []*BulkWriteOperation {
	if x != nil {
		return x.Operations
	}
	return nil
}

func (x *BulkWrite) GetOrdered() bool {
	if x != nil {
		return x.Ordered
	}
	return false
}

func (x *BulkWrite) GetBypassDocumentValidation() bool {
	if x != nil {
		return x.BypassDocumentValidation
	}
	return false
}

func (x *BulkWrite) GetWriteConcern() *WriteConcern {
	if x != nil {
		return x.WriteConcern
	}
	return nil
}

// A single operation in a bulk write.
type BulkWriteOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Operation:
	//
	//	*BulkWriteOperation_Insert
	//	*BulkWriteOperation_Update
	//	*BulkWriteOperation_Delete
	//	*BulkWriteOperation_Replace
	Operation     isBulkWriteOperation_Operation `protobuf_oneof:"operation"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkWriteOperation) Reset() {
	*x = BulkWriteOperation{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkWriteOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkWriteOperation) ProtoMessage() {}

func (x *BulkWriteOperation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkWriteOperation.ProtoReflect.Descriptor instead.
func (*BulkWriteOperation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{19}
}

func (x *BulkWriteOperation) GetOperation() isBulkWriteOperation_Operation {
	if x != nil {
		return x.Operation
	}
	return nil
}

func (x *BulkWriteOperation) GetInsert() *InsertOperation {
	if x != nil {
		if x, ok := x.Operation.(*BulkWriteOperation_Insert); ok {
			return x.Insert
		}
	}
	return nil
}

func (x *BulkWriteOperation) GetUpdate() *UpdateOperation {
	if x != nil {
		if x, ok := x.Operation.(*BulkWriteOperation_Update); ok {
			return x.Update
		}
	}
	return nil
}

func (x *BulkWriteOperation) GetDelete() *DeleteOperation {
	if x != nil {
		if x, ok := x.Operation.(*BulkWriteOperation_Delete); ok {
			return x.Delete
		}
	}
	return nil
}

func (x *BulkWriteOperation) GetReplace() *ReplaceOperation {
	if x != nil {
		if x, ok := x.Operation.(*BulkWriteOperation_Replace); ok {
			return x.Replace
		}
	}
	return nil
}

type isBulkWriteOperation_Operation interface {
	isBulkWriteOperation_Operation()
}

type BulkWriteOperation_Insert struct {
	// Insert a document.
	Insert *InsertOperation `protobuf:"bytes,1,opt,name=insert,proto3,oneof"`
}

type BulkWriteOperation_Update struct {
	// Update document(s).
	Update *UpdateOperation `protobuf:"bytes,2,opt,name=update,proto3,oneof"`
}

type BulkWriteOperation_Delete struct {
	// Delete document(s).
	Delete *DeleteOperation `protobuf:"bytes,3,opt,name=delete,proto3,oneof"`
}

type BulkWriteOperation_Replace struct {
	// Replace a document.
	Replace *ReplaceOperation `protobuf:"bytes,4,opt,name=replace,proto3,oneof"`
}

func (*BulkWriteOperation_Insert) isBulkWriteOperation_Operation() {}

func (*BulkWriteOperation_Update) isBulkWriteOperation_Operation() {}

func (*BulkWriteOperation_Delete) isBulkWriteOperation_Operation() {}

func (*BulkWriteOperation_Replace) isBulkWriteOperation_Operation() {}

// Result of a bulk write.
type BulkWriteResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The total number of documents matched.
	MatchedCount int64 `protobuf:"varint,1,opt,name=matched_count,json=matchedCount,proto3" json:"matched_count,omitempty"`
	// The total number of documents modified.
	ModifiedCount int64 `protobuf:"varint,2,opt,name=modified_count,json=modifiedCount,proto3" json:"modified_count,omitempty"`
	// The total number of documents inserted.
	InsertedCount int64 `protobuf:"varint,3,opt,name=inserted_count,json=insertedCount,proto3" json:"inserted_count,omitempty"`
	// The total number of documents deleted.
	DeletedCount int64 `protobuf:"varint,4,opt,name=deleted_count,json=deletedCount,proto3" json:"deleted_count,omitempty"`
	// The IDs of upserted documents, indexed by operation position.
	UpsertedIds map[int32]*ObjectId `protobuf:"bytes,5,rep,name=upserted_ids,json=upsertedIds,proto3" json:"upserted_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Errors that occurred during the bulk write.
	Errors        []*BulkWriteError `protobuf:"bytes,6,rep,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkWriteResult) Reset() {
	*x = BulkWriteResult{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkWriteResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkWriteResult) ProtoMessage() {}

func (x *BulkWriteResult) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkWriteResult.ProtoReflect.Descriptor instead.
func (*BulkWriteResult) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{20}
}

func (x *BulkWriteResult) GetMatchedCount() int64 {
	if x != nil {
		return x.MatchedCount
	}
	return 0
}

func (x *BulkWriteResult) GetModifiedCount() int64 {
	if x != nil {
		return x.ModifiedCount
	}
	return 0
}

func (x *BulkWriteResult) GetInsertedCount() int64 {
	if x != nil {
		return x.InsertedCount
	}
	return 0
}

func (x *BulkWriteResult) GetDeletedCount() int64 {
	if x != nil {
		return x.DeletedCount
	}
	return 0
}

func (x *BulkWriteResult) GetUpsertedIds() map[int32]*ObjectId {
	if x != nil {
		return x.UpsertedIds
	}
	return nil
}

func (x *BulkWriteResult) GetErrors() []*BulkWriteError {
	if x != nil {
		return x.Errors
	}
	return nil
}

// An error in a bulk write operation.
type BulkWriteError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the operation that failed.
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The error code.
	Code int32 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	// The error message.
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// The operation that failed.
	Operation     *BulkWriteOperation `protobuf:"bytes,4,opt,name=operation,proto3" json:"operation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BulkWriteError) Reset() {
	*x = BulkWriteError{}
	mi := &file_mongorpc_v1_write_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BulkWriteError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BulkWriteError) ProtoMessage() {}

func (x *BulkWriteError) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_write_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BulkWriteError.ProtoReflect.Descriptor instead.
func (*BulkWriteError) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_write_proto_rawDescGZIP(), []int{21}
}

func (x *BulkWriteError) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *BulkWriteError) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *BulkWriteError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BulkWriteError) GetOperation() *BulkWriteOperation {
	if x != nil {
		return x.Operation
	}
	return nil
}

var File_mongorpc_v1_write_proto protoreflect.FileDescriptor

const file_mongorpc_v1_write_proto_rawDesc = "" +
	"\n" +
	"\x17mongorpc/v1/write.proto\x12\vmongorpc.v1\x1a\x17mongorpc/v1/value.proto\x1a\x1amongorpc/v1/document.proto\x1a\x17mongorpc/v1/query.proto\x1a\x1dmongorpc/v1/transaction.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xf2\x02\n" +
	"\x05Write\x12\x1a\n" +
	"\bdatabase\x18\x01 \x01(\tR\bdatabase\x12\x1e\n" +
	"\n" +
	"collection\x18\x02 \x01(\tR\n" +
	"collection\x126\n" +
	"\x06insert\x18\x03 \x01(\v2\x1c.mongorpc.v1.InsertOperationH\x00R\x06insert\x126\n" +
	"\x06update\x18\x04 \x01(\v2\x1c.mongorpc.v1.UpdateOperationH\x00R\x06update\x126\n" +
	"\x06delete\x18\x05 \x01(\v2\x1c.mongorpc.v1.DeleteOperationH\x00R\x06delete\x129\n" +
	"\areplace\x18\x06 \x01(\v2\x1d.mongorpc.v1.ReplaceOperationH\x00R\areplace\x12=\n" +
	"\fprecondition\x18\a \x01(\v2\x19.mongorpc.v1.PreconditionR\fpreconditionB\v\n" +
	"\toperation\"D\n" +
	"\x0fInsertOperation\x121\n" +
	"\bdocument\x18\x01 \x01(\v2\x15.mongorpc.v1.DocumentR\bdocument\"\xbb\x02\n" +
	"\x0fUpdateOperation\x12+\n" +
	"\x06filter\x18\x01 \x01(\v2\x13.mongorpc.v1.FilterR\x06filter\x12/\n" +
	"\x06update\x18\x02 \x01(\v2\x17.mongorpc.v1.UpdateSpecR\x06update\x12\x14\n" +
	"\x05multi\x18\x03 \x01(\bR\x05multi\x12\x16\n" +
	"\x06upsert\x18\x04 \x01(\bR\x06upsert\x12:\n" +
	"\rarray_filters\x18\x05 \x03(\v2\x15.mongorpc.v1.MapValueR\farrayFilters\x124\n" +
	"\tcollation\x18\x06 \x01(\v2\x16.mongorpc.v1.CollationR\tcollation\x12*\n" +
	"\x04hint\x18\a \x01(\v2\x16.mongorpc.v1.IndexHintR\x04hint\"\x97\x01\n" +
	"\n" +
	"UpdateSpec\x12<\n" +
	"\toperators\x18\x01 \x01(\v2\x1c.mongorpc.v1.UpdateOperatorsH\x00R\toperators\x12<\n" +
	"\bpipeline\x18\x02 \x01(\v2\x1e.mongorpc.v1.AggregationUpdateH\x00R\bpipelineB\r\n" +
	"\vupdate_type\"\x9d\t\n" +
	"\x0fUpdateOperators\x127\n" +
	"\x03set\x18\x01 \x03(\v2%.mongorpc.v1.UpdateOperators.SetEntryR\x03set\x12\x14\n" +
	"\x05unset\x18\x02 \x03(\tR\x05unset\x127\n" +
	"\x03inc\x18\x03 \x03(\v2%.mongorpc.v1.UpdateOperators.IncEntryR\x03inc\x127\n" +
	"\x03mul\x18\x04 \x03(\v2%.mongorpc.v1.UpdateOperators.MulEntryR\x03mul\x127\n" +
	"\x03min\x18\x05 \x03(\v2%.mongorpc.v1.UpdateOperators.MinEntryR\x03min\x127\n" +
	"\x03max\x18\x06 \x03(\v2%.mongorpc.v1.UpdateOperators.MaxEntryR\x03max\x12@\n" +
	"\x06rename\x18\a \x03(\v2(.mongorpc.v1.UpdateOperators.RenameEntryR\x06rename\x12?\n" +
	"\fcurrent_date\x18\b \x03(\v2\x1c.mongorpc.v1.CurrentDateSpecR\vcurrentDate\x12Q\n" +
	"\rset_on_insert\x18\t \x03(\v2-.mongorpc.v1.UpdateOperators.SetOnInsertEntryR\vsetOnInsert\x127\n" +
	"\x05array\x18\n" +
	" \x01(\v2!.mongorpc.v1.ArrayUpdateOperatorsR\x05array\x12=\n" +
	"\abitwise\x18\v \x01(\v2#.mongorpc.v1.BitwiseUpdateOperatorsR\abitwise\x1aJ\n" +
	"\bSetEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\x1aJ\n" +
	"\bIncEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\x1aJ\n" +
	"\bMulEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\x1aJ\n" +
	"\bMinEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\x1aJ\n" +
	"\bMaxEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\x1a9\n" +
	"\vRenameEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aR\n" +
	"\x10SetOnInsertEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value:\x028\x01\"\xa2\x01\n" +
	"\x0fCurrentDateSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x129\n" +
	"\x04type\x18\x02 \x01(\x0e2%.mongorpc.v1.CurrentDateSpec.DateTypeR\x04type\">\n" +
	"\bDateType\x12\x19\n" +
	"\x15DATE_TYPE_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04DATE\x10\x01\x12\r\n" +
	"\tTIMESTAMP\x10\x02\"\xda\x02\n" +
	"\x14ArrayUpdateOperators\x12.\n" +
	"\x04push\x18\x01 \x03(\v2\x1a.mongorpc.v1.ArrayPushSpecR\x04push\x12<\n" +
	"\n" +
	"add_to_set\x18\x02 \x03(\v2\x1e.mongorpc.v1.ArrayAddToSetSpecR\baddToSet\x12+\n" +
	"\x03pop\x18\x03 \x03(\v2\x19.mongorpc.v1.ArrayPopSpecR\x03pop\x12.\n" +
	"\x04pull\x18\x04 \x03(\v2\x1a.mongorpc.v1.ArrayPullSpecR\x04pull\x128\n" +
	"\bpull_all\x18\x05 \x03(\v2\x1d.mongorpc.v1.ArrayPullAllSpecR\apullAll\x12=\n" +
	"\n" +
	"positional\x18\x06 \x03(\v2\x1d.mongorpc.v1.PositionalUpdateR\n" +
	"positional\"\xd5\x01\n" +
	"\rArrayPushSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value\x12&\n" +
	"\x04each\x18\x03 \x03(\v2\x12.mongorpc.v1.ValueR\x04each\x12*\n" +
	"\x04sort\x18\x04 \x03(\v2\x16.mongorpc.v1.SortOrderR\x04sort\x12\x14\n" +
	"\x05slice\x18\x05 \x01(\x05R\x05slice\x12\x1a\n" +
	"\bposition\x18\x06 \x01(\x05R\bposition\"{\n" +
	"\x11ArrayAddToSetSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value\x12&\n" +
	"\x04each\x18\x03 \x03(\v2\x12.mongorpc.v1.ValueR\x04each\"@\n" +
	"\fArrayPopSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12\x1a\n" +
	"\bposition\x18\x02 \x01(\x05R\bposition\"W\n" +
	"\rArrayPullSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x120\n" +
	"\tcondition\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\tcondition\"T\n" +
	"\x10ArrayPullAllSpec\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12*\n" +
	"\x06values\x18\x02 \x03(\v2\x12.mongorpc.v1.ValueR\x06values\"r\n" +
	"\x10PositionalUpdate\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\x05value\x12\x1e\n" +
	"\n" +
	"identifier\x18\x03 \x01(\tR\n" +
	"identifier\"\xfc\x02\n" +
	"\x16BitwiseUpdateOperators\x12>\n" +
	"\x03and\x18\x01 \x03(\v2,.mongorpc.v1.BitwiseUpdateOperators.AndEntryR\x03and\x12;\n" +
	"\x02or\x18\x02 \x03(\v2+.mongorpc.v1.BitwiseUpdateOperators.OrEntryR\x02or\x12>\n" +
	"\x03xor\x18\x03 \x03(\v2,.mongorpc.v1.BitwiseUpdateOperators.XorEntryR\x03xor\x1a6\n" +
	"\bAndEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1a5\n" +
	"\aOrEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1a6\n" +
	"\bXorEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"B\n" +
	"\x11AggregationUpdate\x12-\n" +
	"\x06stages\x18\x01 \x03(\v2\x15.mongorpc.v1.MapValueR\x06stages\"\xb6\x01\n" +
	"\x0fDeleteOperation\x12+\n" +
	"\x06filter\x18\x01 \x01(\v2\x13.mongorpc.v1.FilterR\x06filter\x12\x14\n" +
	"\x05multi\x18\x02 \x01(\bR\x05multi\x124\n" +
	"\tcollation\x18\x03 \x01(\v2\x16.mongorpc.v1.CollationR\tcollation\x12*\n" +
	"\x04hint\x18\x04 \x01(\v2\x16.mongorpc.v1.IndexHintR\x04hint\"\xf2\x01\n" +
	"\x10ReplaceOperation\x12+\n" +
	"\x06filter\x18\x01 \x01(\v2\x13.mongorpc.v1.FilterR\x06filter\x127\n" +
	"\vreplacement\x18\x02 \x01(\v2\x15.mongorpc.v1.DocumentR\vreplacement\x12\x16\n" +
	"\x06upsert\x18\x03 \x01(\bR\x06upsert\x124\n" +
	"\tcollation\x18\x04 \x01(\v2\x16.mongorpc.v1.CollationR\tcollation\x12*\n" +
	"\x04hint\x18\x05 \x01(\v2\x16.mongorpc.v1.IndexHintR\x04hint\"\x98\x02\n" +
	"\vWriteResult\x12#\n" +
	"\rmatched_count\x18\x01 \x01(\x03R\fmatchedCount\x12%\n" +
	"\x0emodified_count\x18\x02 \x01(\x03R\rmodifiedCount\x12%\n" +
	"\x0einserted_count\x18\x03 \x01(\x03R\rinsertedCount\x12#\n" +
	"\rdeleted_count\x18\x04 \x01(\x03R\fdeletedCount\x126\n" +
	"\vupserted_id\x18\x05 \x01(\v2\x15.mongorpc.v1.ObjectIdR\n" +
	"upsertedId\x129\n" +
	"\n" +
	"write_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\twriteTime\"\xa0\x02\n" +
	"\tBulkWrite\x12\x1a\n" +
	"\bdatabase\x18\x01 \x01(\tR\bdatabase\x12\x1e\n" +
	"\n" +
	"collection\x18\x02 \x01(\tR\n" +
	"collection\x12?\n" +
	"\n" +
	"operations\x18\x03 \x03(\v2\x1f.mongorpc.v1.BulkWriteOperationR\n" +
	"operations\x12\x18\n" +
	"\aordered\x18\x04 \x01(\bR\aordered\x12<\n" +
	"\x1abypass_document_validation\x18\x05 \x01(\bR\x18bypassDocumentValidation\x12>\n" +
	"\rwrite_concern\x18\x06 \x01(\v2\x19.mongorpc.v1.WriteConcernR\fwriteConcern\"\x84\x02\n" +
	"\x12BulkWriteOperation\x126\n" +
	"\x06insert\x18\x01 \x01(\v2\x1c.mongorpc.v1.InsertOperationH\x00R\x06insert\x126\n" +
	"\x06update\x18\x02 \x01(\v2\x1c.mongorpc.v1.UpdateOperationH\x00R\x06update\x126\n" +
	"\x06delete\x18\x03 \x01(\v2\x1c.mongorpc.v1.DeleteOperationH\x00R\x06delete\x129\n" +
	"\areplace\x18\x04 \x01(\v2\x1d.mongorpc.v1.ReplaceOperationH\x00R\areplaceB\v\n" +
	"\toperation\"\x87\x03\n" +
	"\x0fBulkWriteResult\x12#\n" +
	"\rmatched_count\x18\x01 \x01(\x03R\fmatchedCount\x12%\n" +
	"\x0emodified_count\x18\x02 \x01(\x03R\rmodifiedCount\x12%\n" +
	"\x0einserted_count\x18\x03 \x01(\x03R\rinsertedCount\x12#\n" +
	"\rdeleted_count\x18\x04 \x01(\x03R\fdeletedCount\x12P\n" +
	"\fupserted_ids\x18\x05 \x03(\v2-.mongorpc.v1.BulkWriteResult.UpsertedIdsEntryR\vupsertedIds\x123\n" +
	"\x06errors\x18\x06 \x03(\v2\x1b.mongorpc.v1.BulkWriteErrorR\x06errors\x1aU\n" +
	"\x10UpsertedIdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12+\n" +
	"\x05value\x18\x02 \x01(\v2\x15.mongorpc.v1.ObjectIdR\x05value:\x028\x01\"\x93\x01\n" +
	"\x0eBulkWriteError\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x05R\x05index\x12\x12\n" +
	"\x04code\x18\x02 \x01(\x05R\x04code\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\x12=\n" +
	"\toperation\x18\x04 \x01(\v2\x1f.mongorpc.v1.BulkWriteOperationR\toperationB\xa3\x01\n" +
	"\x0fcom.mongorpc.v1B\n" +
	"WriteProtoP\x01Z7github.com/mongorpc/mongorpc/gen/mongorpc/v1;mongorpcv1\xa2\x02\x03MXX\xaa\x02\vMongorpc.V1\xca\x02\vMongorpc\\V1\xe2\x02\x17Mongorpc\\V1\\GPBMetadata\xea\x02\fMongorpc::V1b\x06proto3"

var (
	file_mongorpc_v1_write_proto_rawDescOnce sync.Once
	file_mongorpc_v1_write_proto_rawDescData []byte
)

func file_mongorpc_v1_write_proto_rawDescGZIP() []byte {
	file_mongorpc_v1_write_proto_rawDescOnce.Do(func() {
		file_mongorpc_v1_write_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_mongorpc_v1_write_proto_rawDesc), len(file_mongorpc_v1_write_proto_rawDesc)))
	})
	return file_mongorpc_v1_write_proto_rawDescData
}

var file_mongorpc_v1_write_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_mongorpc_v1_write_proto_msgTypes = make([]protoimpl.MessageInfo, 33)
var file_mongorpc_v1_write_proto_goTypes = []any{
	(CurrentDateSpec_DateType)(0),  // 0: mongorpc.v1.CurrentDateSpec.DateType
	(*Write)(nil),                  // 1: mongorpc.v1.Write
	(*InsertOperation)(nil),        // 2: mongorpc.v1.InsertOperation
	(*UpdateOperation)(nil),        // 3: mongorpc.v1.UpdateOperation
	(*UpdateSpec)(nil),             // 4: mongorpc.v1.UpdateSpec
	(*UpdateOperators)(nil),        // 5: mongorpc.v1.UpdateOperators
	(*CurrentDateSpec)(nil),        // 6: mongorpc.v1.CurrentDateSpec
	(*ArrayUpdateOperators)(nil),   // 7: mongorpc.v1.ArrayUpdateOperators
	(*ArrayPushSpec)(nil),          // 8: mongorpc.v1.ArrayPushSpec
	(*ArrayAddToSetSpec)(nil),      // 9: mongorpc.v1.ArrayAddToSetSpec
	(*ArrayPopSpec)(nil),           // 10: mongorpc.v1.ArrayPopSpec
	(*ArrayPullSpec)(nil),          // 11: mongorpc.v1.ArrayPullSpec
	(*ArrayPullAllSpec)(nil),       // 12: mongorpc.v1.ArrayPullAllSpec
	(*PositionalUpdate)(nil),       // 13: mongorpc.v1.PositionalUpdate
	(*BitwiseUpdateOperators)(nil), // 14: mongorpc.v1.BitwiseUpdateOperators
	(*AggregationUpdate)(nil),      // 15: mongorpc.v1.AggregationUpdate
	(*DeleteOperation)(nil),        // 16: mongorpc.v1.DeleteOperation
	(*ReplaceOperation)(nil),       // 17: mongorpc.v1.ReplaceOperation
	(*WriteResult)(nil),            // 18: mongorpc.v1.WriteResult
	(*BulkWrite)(nil),              // 19: mongorpc.v1.BulkWrite
	(*BulkWriteOperation)(nil),     // 20: mongorpc.v1.BulkWriteOperation
	(*BulkWriteResult)(nil),        // 21: mongorpc.v1.BulkWriteResult
	(*BulkWriteError)(nil),         // 22: mongorpc.v1.BulkWriteError
	nil,                            // 23: mongorpc.v1.UpdateOperators.SetEntry
	nil,                            // 24: mongorpc.v1.UpdateOperators.IncEntry
	nil,                            // 25: mongorpc.v1.UpdateOperators.MulEntry
	nil,                            // 26: mongorpc.v1.UpdateOperators.MinEntry
	nil,                            // 27: mongorpc.v1.UpdateOperators.MaxEntry
	nil,                            // 28: mongorpc.v1.UpdateOperators.RenameEntry
	nil,                            // 29: mongorpc.v1.UpdateOperators.SetOnInsertEntry
	nil,                            // 30: mongorpc.v1.BitwiseUpdateOperators.AndEntry
	nil,                            // 31: mongorpc.v1.BitwiseUpdateOperators.OrEntry
	nil,                            // 32: mongorpc.v1.BitwiseUpdateOperators.XorEntry
	nil,                            // 33: mongorpc.v1.BulkWriteResult.UpsertedIdsEntry
	(*Precondition)(nil),           // 34: mongorpc.v1.Precondition
	(*Document)(nil),               // 35: mongorpc.v1.Document
	(*Filter)(nil),                 // 36: mongorpc.v1.Filter
	(*MapValue)(nil),               // 37: mongorpc.v1.MapValue
	(*Collation)(nil),              // 38: mongorpc.v1.Collation
	(*IndexHint)(nil),              // 39: mongorpc.v1.IndexHint
	(*Value)(nil),                  // 40: mongorpc.v1.Value
	(*SortOrder)(nil),              // 41: mongorpc.v1.SortOrder
	(*ObjectId)(nil),               // 42: mongorpc.v1.ObjectId
	(*timestamppb.Timestamp)(nil),  // 43: google.protobuf.Timestamp
	(*WriteConcern)(nil),           // 44: mongorpc.v1.WriteConcern
}
var file_mongorpc_v1_write_proto_depIdxs = []int32{
	2,  // 0: mongorpc.v1.Write.insert:type_name -> mongorpc.v1.InsertOperation
	3,  // 1: mongorpc.v1.Write.update:type_name -> mongorpc.v1.UpdateOperation
	16, // 2: mongorpc.v1.Write.delete:type_name -> mongorpc.v1.DeleteOperation
	17, // 3: mongorpc.v1.Write.replace:type_name -> mongorpc.v1.ReplaceOperation
	34, // 4: mongorpc.v1.Write.precondition:type_name -> mongorpc.v1.Precondition
	35, // 5: mongorpc.v1.InsertOperation.document:type_name -> mongorpc.v1.Document
	36, // 6: mongorpc.v1.UpdateOperation.filter:type_name -> mongorpc.v1.Filter
	4,  // 7: mongorpc.v1.UpdateOperation.update:type_name -> mongorpc.v1.UpdateSpec
	37, // 8: mongorpc.v1.UpdateOperation.array_filters:type_name -> mongorpc.v1.MapValue
	38, // 9: mongorpc.v1.UpdateOperation.collation:type_name -> mongorpc.v1.Collation
	39, // 10: mongorpc.v1.UpdateOperation.hint:type_name -> mongorpc.v1.IndexHint
	5,  // 11: mongorpc.v1.UpdateSpec.operators:type_name -> mongorpc.v1.UpdateOperators
	15, // 12: mongorpc.v1.UpdateSpec.pipeline:type_name -> mongorpc.v1.AggregationUpdate
	23, // 13: mongorpc.v1.UpdateOperators.set:type_name -> mongorpc.v1.UpdateOperators.SetEntry
	24, // 14: mongorpc.v1.UpdateOperators.inc:type_name -> mongorpc.v1.UpdateOperators.IncEntry
	25, // 15: mongorpc.v1.UpdateOperators.mul:type_name -> mongorpc.v1.UpdateOperators.MulEntry
	26, // 16: mongorpc.v1.UpdateOperators.min:type_name -> mongorpc.v1.UpdateOperators.MinEntry
	27, // 17: mongorpc.v1.UpdateOperators.max:type_name -> mongorpc.v1.UpdateOperators.MaxEntry
	28, // 18: mongorpc.v1.UpdateOperators.rename:type_name -> mongorpc.v1.UpdateOperators.RenameEntry
	6,  // 19: mongorpc.v1.UpdateOperators.current_date:type_name -> mongorpc.v1.CurrentDateSpec
	29, // 20: mongorpc.v1.UpdateOperators.set_on_insert:type_name -> mongorpc.v1.UpdateOperators.SetOnInsertEntry
	7,  // 21: mongorpc.v1.UpdateOperators.array:type_name -> mongorpc.v1.ArrayUpdateOperators
	14, // 22: mongorpc.v1.UpdateOperators.bitwise:type_name -> mongorpc.v1.BitwiseUpdateOperators
	0,  // 23: mongorpc.v1.CurrentDateSpec.type:type_name -> mongorpc.v1.CurrentDateSpec.DateType
	8,  // 24: mongorpc.v1.ArrayUpdateOperators.push:type_name -> mongorpc.v1.ArrayPushSpec
	9,  // 25: mongorpc.v1.ArrayUpdateOperators.add_to_set:type_name -> mongorpc.v1.ArrayAddToSetSpec
	10, // 26: mongorpc.v1.ArrayUpdateOperators.pop:type_name -> mongorpc.v1.ArrayPopSpec
	11, // 27: mongorpc.v1.ArrayUpdateOperators.pull:type_name -> mongorpc.v1.ArrayPullSpec
	12, // 28: mongorpc.v1.ArrayUpdateOperators.pull_all:type_name -> mongorpc.v1.ArrayPullAllSpec
	13, // 29: mongorpc.v1.ArrayUpdateOperators.positional:type_name -> mongorpc.v1.PositionalUpdate
	40, // 30: mongorpc.v1.ArrayPushSpec.value:type_name -> mongorpc.v1.Value
	40, // 31: mongorpc.v1.ArrayPushSpec.each:type_name -> mongorpc.v1.Value
	41, // 32: mongorpc.v1.ArrayPushSpec.sort:type_name -> mongorpc.v1.SortOrder
	40, // 33: mongorpc.v1.ArrayAddToSetSpec.value:type_name -> mongorpc.v1.Value
	40, // 34: mongorpc.v1.ArrayAddToSetSpec.each:type_name -> mongorpc.v1.Value
	40, // 35: mongorpc.v1.ArrayPullSpec.condition:type_name -> mongorpc.v1.Value
	40, // 36: mongorpc.v1.ArrayPullAllSpec.values:type_name -> mongorpc.v1.Value
	40, // 37: mongorpc.v1.PositionalUpdate.value:type_name -> mongorpc.v1.Value
	30, // 38: mongorpc.v1.BitwiseUpdateOperators.and:type_name -> mongorpc.v1.BitwiseUpdateOperators.AndEntry
	31, // 39: mongorpc.v1.BitwiseUpdateOperators.or:type_name -> mongorpc.v1.BitwiseUpdateOperators.OrEntry
	32, // 40: mongorpc.v1.BitwiseUpdateOperators.xor:type_name -> mongorpc.v1.BitwiseUpdateOperators.XorEntry
	37, // 41: mongorpc.v1.AggregationUpdate.stages:type_name -> mongorpc.v1.MapValue
	36, // 42: mongorpc.v1.DeleteOperation.filter:type_name -> mongorpc.v1.Filter
	38, // 43: mongorpc.v1.DeleteOperation.collation:type_name -> mongorpc.v1.Collation
	39, // 44: mongorpc.v1.DeleteOperation.hint:type_name -> mongorpc.v1.IndexHint
	36, // 45: mongorpc.v1.ReplaceOperation.filter:type_name -> mongorpc.v1.Filter
	35, // 46: mongorpc.v1.ReplaceOperation.replacement:type_name -> mongorpc.v1.Document
	38, // 47: mongorpc.v1.ReplaceOperation.collation:type_name -> mongorpc.v1.Collation
	39, // 48: mongorpc.v1.ReplaceOperation.hint:type_name -> mongorpc.v1.IndexHint
	42, // 49: mongorpc.v1.WriteResult.upserted_id:type_name -> mongorpc.v1.ObjectId
	43, // 50: mongorpc.v1.WriteResult.write_time:type_name -> google.protobuf.Timestamp
	20, // 51: mongorpc.v1.BulkWrite.operations:type_name -> mongorpc.v1.BulkWriteOperation
	44, // 52: mongorpc.v1.BulkWrite.write_concern:type_name -> mongorpc.v1.WriteConcern
	2,  // 53: mongorpc.v1.BulkWriteOperation.insert:type_name -> mongorpc.v1.InsertOperation
	3,  // 54: mongorpc.v1.BulkWriteOperation.update:type_name -> mongorpc.v1.UpdateOperation
	16, // 55: mongorpc.v1.BulkWriteOperation.delete:type_name -> mongorpc.v1.DeleteOperation
	17, // 56: mongorpc.v1.BulkWriteOperation.replace:type_name -> mongorpc.v1.ReplaceOperation
	33, // 57: mongorpc.v1.BulkWriteResult.upserted_ids:type_name -> mongorpc.v1.BulkWriteResult.UpsertedIdsEntry
	22, // 58: mongorpc.v1.BulkWriteResult.errors:type_name -> mongorpc.v1.BulkWriteError
	20, // 59: mongorpc.v1.BulkWriteError.operation:type_name -> mongorpc.v1.BulkWriteOperation
	40, // 60: mongorpc.v1.UpdateOperators.SetEntry.value:type_name -> mongorpc.v1.Value
	40, // 61: mongorpc.v1.UpdateOperators.IncEntry.value:type_name -> mongorpc.v1.Value
	40, // 62: mongorpc.v1.UpdateOperators.MulEntry.value:type_name -> mongorpc.v1.Value
	40, // 63: mongorpc.v1.UpdateOperators.MinEntry.value:type_name -> mongorpc.v1.Value
	40, // 64: mongorpc.v1.UpdateOperators.MaxEntry.value:type_name -> mongorpc.v1.Value
	40, // 65: mongorpc.v1.UpdateOperators.SetOnInsertEntry.value:type_name -> mongorpc.v1.Value
	42, // 66: mongorpc.v1.BulkWriteResult.UpsertedIdsEntry.value:type_name -> mongorpc.v1.ObjectId
	67, // [67:67] is the sub-list for method output_type
	67, // [67:67] is the sub-list for method input_type
	67, // [67:67] is the sub-list for extension type_name
	67, // [67:67] is the sub-list for extension extendee
	0,  // [0:67] is the sub-list for field type_name
}

func init() { file_mongorpc_v1_write_proto_init() }
func file_mongorpc_v1_write_proto_init() {
	if File_mongorpc_v1_write_proto != nil {
		return
	}
	file_mongorpc_v1_value_proto_init()
	file_mongorpc_v1_document_proto_init()
	file_mongorpc_v1_query_proto_init()
	file_mongorpc_v1_transaction_proto_init()
	file_mongorpc_v1_write_proto_msgTypes[0].OneofWrappers = []any{
		(*Write_Insert)(nil),
		(*Write_Update)(nil),
		(*Write_Delete)(nil),
		(*Write_Replace)(nil),
	}
	file_mongorpc_v1_write_proto_msgTypes[3].OneofWrappers = []any{
		(*UpdateSpec_Operators)(nil),
		(*UpdateSpec_Pipeline)(nil),
	}
	file_mongorpc_v1_write_proto_msgTypes[19].OneofWrappers = []any{
		(*BulkWriteOperation_Insert)(nil),
		(*BulkWriteOperation_Update)(nil),
		(*BulkWriteOperation_Delete)(nil),
		(*BulkWriteOperation_Replace)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_mongorpc_v1_write_proto_rawDesc), len(file_mongorpc_v1_write_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   33,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mongorpc_v1_write_proto_goTypes,
		DependencyIndexes: file_mongorpc_v1_write_proto_depIdxs,
		EnumInfos:         file_mongorpc_v1_write_proto_enumTypes,
		MessageInfos:      file_mongorpc_v1_write_proto_msgTypes,
	}.Build()
	File_mongorpc_v1_write_proto = out.File
	file_mongorpc_v1_write_proto_goTypes = nil
	file_mongorpc_v1_write_proto_depIdxs = nil
}
