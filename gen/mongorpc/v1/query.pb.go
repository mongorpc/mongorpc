// Copyright 2024 MongoRPC
// SPDX-License-Identifier: Apache-2.0
//
// Query definitions for MongoRPC.
// This file defines structured queries and aggregation pipelines.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: mongorpc/v1/query.proto

package mongorpcv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The operator for combining filters.
type CompositeFilter_Operator int32

const (
	// Unspecified operator.
	CompositeFilter_OPERATOR_UNSPECIFIED CompositeFilter_Operator = 0
	// All filters must match ($and).
	CompositeFilter_AND CompositeFilter_Operator = 1
	// At least one filter must match ($or).
	CompositeFilter_OR CompositeFilter_Operator = 2
	// None of the filters must match ($nor).
	CompositeFilter_NOR CompositeFilter_Operator = 3
)

// Enum value maps for CompositeFilter_Operator.
var (
	CompositeFilter_Operator_name = map[int32]string{
		0: "OPERATOR_UNSPECIFIED",
		1: "AND",
		2: "OR",
		3: "NOR",
	}
	CompositeFilter_Operator_value = map[string]int32{
		"OPERATOR_UNSPECIFIED": 0,
		"AND":                  1,
		"OR":                   2,
		"NOR":                  3,
	}
)

func (x CompositeFilter_Operator) Enum() *CompositeFilter_Operator {
	p := new(CompositeFilter_Operator)
	*p = x
	return p
}

func (x CompositeFilter_Operator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompositeFilter_Operator) Descriptor() protoreflect.EnumDescriptor {
	return file_mongorpc_v1_query_proto_enumTypes[0].Descriptor()
}

func (CompositeFilter_Operator) Type() protoreflect.EnumType {
	return &file_mongorpc_v1_query_proto_enumTypes[0]
}

func (x CompositeFilter_Operator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompositeFilter_Operator.Descriptor instead.
func (CompositeFilter_Operator) EnumDescriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{2, 0}
}

// A field filter operator.
type FieldFilter_Operator int32

const (
	// Unspecified operator.
	FieldFilter_OPERATOR_UNSPECIFIED FieldFilter_Operator = 0
	// Equal ($eq).
	FieldFilter_EQUAL FieldFilter_Operator = 1
	// Not equal ($ne).
	FieldFilter_NOT_EQUAL FieldFilter_Operator = 2
	// Less than ($lt).
	FieldFilter_LESS_THAN FieldFilter_Operator = 3
	// Less than or equal ($lte).
	FieldFilter_LESS_THAN_OR_EQUAL FieldFilter_Operator = 4
	// Greater than ($gt).
	FieldFilter_GREATER_THAN FieldFilter_Operator = 5
	// Greater than or equal ($gte).
	FieldFilter_GREATER_THAN_OR_EQUAL FieldFilter_Operator = 6
	// In array ($in).
	FieldFilter_IN FieldFilter_Operator = 7
	// Not in array ($nin).
	FieldFilter_NOT_IN FieldFilter_Operator = 8
	// Array contains ($elemMatch with equality).
	FieldFilter_ARRAY_CONTAINS FieldFilter_Operator = 9
	// Array contains any ($elemMatch with $in).
	FieldFilter_ARRAY_CONTAINS_ANY FieldFilter_Operator = 10
	// Field exists ($exists: true).
	FieldFilter_EXISTS FieldFilter_Operator = 11
	// Field does not exist ($exists: false).
	FieldFilter_NOT_EXISTS FieldFilter_Operator = 12
	// Type check ($type).
	FieldFilter_TYPE FieldFilter_Operator = 13
	// Regex match ($regex).
	FieldFilter_REGEX FieldFilter_Operator = 14
	// Text search ($text).
	FieldFilter_TEXT FieldFilter_Operator = 15
	// Modulo ($mod).
	FieldFilter_MOD FieldFilter_Operator = 16
	// Array size ($size).
	FieldFilter_SIZE FieldFilter_Operator = 17
	// Bits all clear ($bitsAllClear).
	FieldFilter_BITS_ALL_CLEAR FieldFilter_Operator = 18
	// Bits all set ($bitsAllSet).
	FieldFilter_BITS_ALL_SET FieldFilter_Operator = 19
	// Bits any clear ($bitsAnyClear).
	FieldFilter_BITS_ANY_CLEAR FieldFilter_Operator = 20
	// Bits any set ($bitsAnySet).
	FieldFilter_BITS_ANY_SET FieldFilter_Operator = 21
)

// Enum value maps for FieldFilter_Operator.
var (
	FieldFilter_Operator_name = map[int32]string{
		0:  "OPERATOR_UNSPECIFIED",
		1:  "EQUAL",
		2:  "NOT_EQUAL",
		3:  "LESS_THAN",
		4:  "LESS_THAN_OR_EQUAL",
		5:  "GREATER_THAN",
		6:  "GREATER_THAN_OR_EQUAL",
		7:  "IN",
		8:  "NOT_IN",
		9:  "ARRAY_CONTAINS",
		10: "ARRAY_CONTAINS_ANY",
		11: "EXISTS",
		12: "NOT_EXISTS",
		13: "TYPE",
		14: "REGEX",
		15: "TEXT",
		16: "MOD",
		17: "SIZE",
		18: "BITS_ALL_CLEAR",
		19: "BITS_ALL_SET",
		20: "BITS_ANY_CLEAR",
		21: "BITS_ANY_SET",
	}
	FieldFilter_Operator_value = map[string]int32{
		"OPERATOR_UNSPECIFIED":  0,
		"EQUAL":                 1,
		"NOT_EQUAL":             2,
		"LESS_THAN":             3,
		"LESS_THAN_OR_EQUAL":    4,
		"GREATER_THAN":          5,
		"GREATER_THAN_OR_EQUAL": 6,
		"IN":                    7,
		"NOT_IN":                8,
		"ARRAY_CONTAINS":        9,
		"ARRAY_CONTAINS_ANY":    10,
		"EXISTS":                11,
		"NOT_EXISTS":            12,
		"TYPE":                  13,
		"REGEX":                 14,
		"TEXT":                  15,
		"MOD":                   16,
		"SIZE":                  17,
		"BITS_ALL_CLEAR":        18,
		"BITS_ALL_SET":          19,
		"BITS_ANY_CLEAR":        20,
		"BITS_ANY_SET":          21,
	}
)

func (x FieldFilter_Operator) Enum() *FieldFilter_Operator {
	p := new(FieldFilter_Operator)
	*p = x
	return p
}

func (x FieldFilter_Operator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FieldFilter_Operator) Descriptor() protoreflect.EnumDescriptor {
	return file_mongorpc_v1_query_proto_enumTypes[1].Descriptor()
}

func (FieldFilter_Operator) Type() protoreflect.EnumType {
	return &file_mongorpc_v1_query_proto_enumTypes[1]
}

func (x FieldFilter_Operator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FieldFilter_Operator.Descriptor instead.
func (FieldFilter_Operator) EnumDescriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{3, 0}
}

// The read preference mode.
type ReadPreference_Mode int32

const (
	// Unspecified (defaults to PRIMARY).
	ReadPreference_MODE_UNSPECIFIED ReadPreference_Mode = 0
	// Read from the primary only.
	ReadPreference_PRIMARY ReadPreference_Mode = 1
	// Prefer primary, fall back to secondary.
	ReadPreference_PRIMARY_PREFERRED ReadPreference_Mode = 2
	// Read from secondary only.
	ReadPreference_SECONDARY ReadPreference_Mode = 3
	// Prefer secondary, fall back to primary.
	ReadPreference_SECONDARY_PREFERRED ReadPreference_Mode = 4
	// Read from the nearest member.
	ReadPreference_NEAREST ReadPreference_Mode = 5
)

// Enum value maps for ReadPreference_Mode.
var (
	ReadPreference_Mode_name = map[int32]string{
		0: "MODE_UNSPECIFIED",
		1: "PRIMARY",
		2: "PRIMARY_PREFERRED",
		3: "SECONDARY",
		4: "SECONDARY_PREFERRED",
		5: "NEAREST",
	}
	ReadPreference_Mode_value = map[string]int32{
		"MODE_UNSPECIFIED":    0,
		"PRIMARY":             1,
		"PRIMARY_PREFERRED":   2,
		"SECONDARY":           3,
		"SECONDARY_PREFERRED": 4,
		"NEAREST":             5,
	}
)

func (x ReadPreference_Mode) Enum() *ReadPreference_Mode {
	p := new(ReadPreference_Mode)
	*p = x
	return p
}

func (x ReadPreference_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReadPreference_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_mongorpc_v1_query_proto_enumTypes[2].Descriptor()
}

func (ReadPreference_Mode) Type() protoreflect.EnumType {
	return &file_mongorpc_v1_query_proto_enumTypes[2]
}

func (x ReadPreference_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReadPreference_Mode.Descriptor instead.
func (ReadPreference_Mode) EnumDescriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{13, 0}
}

// A MongoDB query.
// Provides a structured way to query documents similar to the MongoDB find() operation.
type Query struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The database to query.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// The collection to query.
	Collection string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
	// The filter to apply. Uses MongoDB query operators.
	Filter *Filter `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	// The fields to return (projection).
	Projection *Projection `protobuf:"bytes,4,opt,name=projection,proto3" json:"projection,omitempty"`
	// The sort order for results.
	Sort []*SortOrder `protobuf:"bytes,5,rep,name=sort,proto3" json:"sort,omitempty"`
	// The number of documents to skip before returning results.
	Skip int64 `protobuf:"varint,6,opt,name=skip,proto3" json:"skip,omitempty"`
	// The maximum number of documents to return.
	Limit *wrapperspb.Int64Value `protobuf:"bytes,7,opt,name=limit,proto3" json:"limit,omitempty"`
	// Optional hint for which index to use.
	Hint *IndexHint `protobuf:"bytes,8,opt,name=hint,proto3" json:"hint,omitempty"`
	// Read preference for replica set queries.
	ReadPreference *ReadPreference `protobuf:"bytes,9,opt,name=read_preference,json=readPreference,proto3" json:"read_preference,omitempty"`
	// Collation for string comparison.
	Collation     *Collation `protobuf:"bytes,10,opt,name=collation,proto3" json:"collation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Query) Reset() {
	*x = Query{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Query) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Query) ProtoMessage() {}

func (x *Query) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Query.ProtoReflect.Descriptor instead.
func (*Query) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{0}
}

func (x *Query) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *Query) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *Query) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *Query) GetProjection() *Projection {
	if x != nil {
		return x.Projection
	}
	return nil
}

func (x *Query) GetSort() []*SortOrder {
	if x != nil {
		return x.Sort
	}
	return nil
}

func (x *Query) GetSkip() int64 {
	if x != nil {
		return x.Skip
	}
	return 0
}

func (x *Query) GetLimit() *wrapperspb.Int64Value {
	if x != nil {
		return x.Limit
	}
	return nil
}

func (x *Query) GetHint() *IndexHint {
	if x != nil {
		return x.Hint
	}
	return nil
}

func (x *Query) GetReadPreference() *ReadPreference {
	if x != nil {
		return x.ReadPreference
	}
	return nil
}

func (x *Query) GetCollation() *Collation {
	if x != nil {
		return x.Collation
	}
	return nil
}

// A filter for querying documents.
type Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of filter.
	//
	// Types that are valid to be assigned to FilterType:
	//
	//	*Filter_Composite
	//	*Filter_Field
	//	*Filter_Raw
	FilterType    isFilter_FilterType `protobuf_oneof:"filter_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Filter) Reset() {
	*x = Filter{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Filter) ProtoMessage() {}

func (x *Filter) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Filter.ProtoReflect.Descriptor instead.
func (*Filter) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{1}
}

func (x *Filter) GetFilterType() isFilter_FilterType {
	if x != nil {
		return x.FilterType
	}
	return nil
}

func (x *Filter) GetComposite() *CompositeFilter {
	if x != nil {
		if x, ok := x.FilterType.(*Filter_Composite); ok {
			return x.Composite
		}
	}
	return nil
}

func (x *Filter) GetField() *FieldFilter {
	if x != nil {
		if x, ok := x.FilterType.(*Filter_Field); ok {
			return x.Field
		}
	}
	return nil
}

func (x *Filter) GetRaw() *MapValue {
	if x != nil {
		if x, ok := x.FilterType.(*Filter_Raw); ok {
			return x.Raw
		}
	}
	return nil
}

type isFilter_FilterType interface {
	isFilter_FilterType()
}

type Filter_Composite struct {
	// A composite filter (AND, OR, NOR).
	Composite *CompositeFilter `protobuf:"bytes,1,opt,name=composite,proto3,oneof"`
}

type Filter_Field struct {
	// A field filter (comparison on a single field).
	Field *FieldFilter `protobuf:"bytes,2,opt,name=field,proto3,oneof"`
}

type Filter_Raw struct {
	// A raw MongoDB query filter (for advanced queries).
	Raw *MapValue `protobuf:"bytes,3,opt,name=raw,proto3,oneof"`
}

func (*Filter_Composite) isFilter_FilterType() {}

func (*Filter_Field) isFilter_FilterType() {}

func (*Filter_Raw) isFilter_FilterType() {}

// A composite filter that combines multiple filters.
type CompositeFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The operator for combining filters.
	Op CompositeFilter_Operator `protobuf:"varint,1,opt,name=op,proto3,enum=mongorpc.v1.CompositeFilter_Operator" json:"op,omitempty"`
	// The filters to combine.
	Filters       []*Filter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompositeFilter) Reset() {
	*x = CompositeFilter{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompositeFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompositeFilter) ProtoMessage() {}

func (x *CompositeFilter) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompositeFilter.ProtoReflect.Descriptor instead.
func (*CompositeFilter) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{2}
}

func (x *CompositeFilter) GetOp() CompositeFilter_Operator {
	if x != nil {
		return x.Op
	}
	return CompositeFilter_OPERATOR_UNSPECIFIED
}

func (x *CompositeFilter) GetFilters() []*Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

// A filter on a specific field.
type FieldFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field path to filter on. Use dot notation for nested fields.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The operator to apply.
	Op FieldFilter_Operator `protobuf:"varint,2,opt,name=op,proto3,enum=mongorpc.v1.FieldFilter_Operator" json:"op,omitempty"`
	// The value to compare against.
	Value         *Value `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FieldFilter) Reset() {
	*x = FieldFilter{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FieldFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FieldFilter) ProtoMessage() {}

func (x *FieldFilter) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FieldFilter.ProtoReflect.Descriptor instead.
func (*FieldFilter) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{3}
}

func (x *FieldFilter) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *FieldFilter) GetOp() FieldFilter_Operator {
	if x != nil {
		return x.Op
	}
	return FieldFilter_OPERATOR_UNSPECIFIED
}

func (x *FieldFilter) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

// Geospatial filter for location-based queries.
type GeoFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of geospatial query.
	//
	// Types that are valid to be assigned to GeoType:
	//
	//	*GeoFilter_Near
	//	*GeoFilter_Within
	//	*GeoFilter_Intersects
	GeoType       isGeoFilter_GeoType `protobuf_oneof:"geo_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoFilter) Reset() {
	*x = GeoFilter{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoFilter) ProtoMessage() {}

func (x *GeoFilter) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoFilter.ProtoReflect.Descriptor instead.
func (*GeoFilter) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{4}
}

func (x *GeoFilter) GetGeoType() isGeoFilter_GeoType {
	if x != nil {
		return x.GeoType
	}
	return nil
}

func (x *GeoFilter) GetNear() *GeoNear {
	if x != nil {
		if x, ok := x.GeoType.(*GeoFilter_Near); ok {
			return x.Near
		}
	}
	return nil
}

func (x *GeoFilter) GetWithin() *GeoWithin {
	if x != nil {
		if x, ok := x.GeoType.(*GeoFilter_Within); ok {
			return x.Within
		}
	}
	return nil
}

func (x *GeoFilter) GetIntersects() *GeoIntersects {
	if x != nil {
		if x, ok := x.GeoType.(*GeoFilter_Intersects); ok {
			return x.Intersects
		}
	}
	return nil
}

type isGeoFilter_GeoType interface {
	isGeoFilter_GeoType()
}

type GeoFilter_Near struct {
	// Find documents near a point ($near, $nearSphere).
	Near *GeoNear `protobuf:"bytes,1,opt,name=near,proto3,oneof"`
}

type GeoFilter_Within struct {
	// Find documents within a geometry ($geoWithin).
	Within *GeoWithin `protobuf:"bytes,2,opt,name=within,proto3,oneof"`
}

type GeoFilter_Intersects struct {
	// Find documents that intersect a geometry ($geoIntersects).
	Intersects *GeoIntersects `protobuf:"bytes,3,opt,name=intersects,proto3,oneof"`
}

func (*GeoFilter_Near) isGeoFilter_GeoType() {}

func (*GeoFilter_Within) isGeoFilter_GeoType() {}

func (*GeoFilter_Intersects) isGeoFilter_GeoType() {}

// Query for documents near a point.
type GeoNear struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field containing the geospatial data.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The point to search near.
	Point *GeoPoint `protobuf:"bytes,2,opt,name=point,proto3" json:"point,omitempty"`
	// Maximum distance in meters.
	MaxDistance float64 `protobuf:"fixed64,3,opt,name=max_distance,json=maxDistance,proto3" json:"max_distance,omitempty"`
	// Minimum distance in meters.
	MinDistance float64 `protobuf:"fixed64,4,opt,name=min_distance,json=minDistance,proto3" json:"min_distance,omitempty"`
	// Whether to use spherical geometry.
	Spherical     bool `protobuf:"varint,5,opt,name=spherical,proto3" json:"spherical,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoNear) Reset() {
	*x = GeoNear{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoNear) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoNear) ProtoMessage() {}

func (x *GeoNear) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoNear.ProtoReflect.Descriptor instead.
func (*GeoNear) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{5}
}

func (x *GeoNear) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *GeoNear) GetPoint() *GeoPoint {
	if x != nil {
		return x.Point
	}
	return nil
}

func (x *GeoNear) GetMaxDistance() float64 {
	if x != nil {
		return x.MaxDistance
	}
	return 0
}

func (x *GeoNear) GetMinDistance() float64 {
	if x != nil {
		return x.MinDistance
	}
	return 0
}

func (x *GeoNear) GetSpherical() bool {
	if x != nil {
		return x.Spherical
	}
	return false
}

// Query for documents within a geometry.
type GeoWithin struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field containing the geospatial data.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The geometry type.
	//
	// Types that are valid to be assigned to Geometry:
	//
	//	*GeoWithin_Box
	//	*GeoWithin_Polygon
	//	*GeoWithin_Circle
	Geometry      isGeoWithin_Geometry `protobuf_oneof:"geometry"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoWithin) Reset() {
	*x = GeoWithin{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoWithin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoWithin) ProtoMessage() {}

func (x *GeoWithin) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoWithin.ProtoReflect.Descriptor instead.
func (*GeoWithin) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{6}
}

func (x *GeoWithin) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *GeoWithin) GetGeometry() isGeoWithin_Geometry {
	if x != nil {
		return x.Geometry
	}
	return nil
}

func (x *GeoWithin) GetBox() *BoundingBox {
	if x != nil {
		if x, ok := x.Geometry.(*GeoWithin_Box); ok {
			return x.Box
		}
	}
	return nil
}

func (x *GeoWithin) GetPolygon() *Polygon {
	if x != nil {
		if x, ok := x.Geometry.(*GeoWithin_Polygon); ok {
			return x.Polygon
		}
	}
	return nil
}

func (x *GeoWithin) GetCircle() *Circle {
	if x != nil {
		if x, ok := x.Geometry.(*GeoWithin_Circle); ok {
			return x.Circle
		}
	}
	return nil
}

type isGeoWithin_Geometry interface {
	isGeoWithin_Geometry()
}

type GeoWithin_Box struct {
	// A bounding box.
	Box *BoundingBox `protobuf:"bytes,2,opt,name=box,proto3,oneof"`
}

type GeoWithin_Polygon struct {
	// A polygon.
	Polygon *Polygon `protobuf:"bytes,3,opt,name=polygon,proto3,oneof"`
}

type GeoWithin_Circle struct {
	// A circle (center sphere).
	Circle *Circle `protobuf:"bytes,4,opt,name=circle,proto3,oneof"`
}

func (*GeoWithin_Box) isGeoWithin_Geometry() {}

func (*GeoWithin_Polygon) isGeoWithin_Geometry() {}

func (*GeoWithin_Circle) isGeoWithin_Geometry() {}

// Query for documents that intersect a geometry.
type GeoIntersects struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field containing the geospatial data.
	Field string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	// The geometry to check intersection with.
	Geometry      *GeoJSON `protobuf:"bytes,2,opt,name=geometry,proto3" json:"geometry,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoIntersects) Reset() {
	*x = GeoIntersects{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoIntersects) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoIntersects) ProtoMessage() {}

func (x *GeoIntersects) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoIntersects.ProtoReflect.Descriptor instead.
func (*GeoIntersects) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{7}
}

func (x *GeoIntersects) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *GeoIntersects) GetGeometry() *GeoJSON {
	if x != nil {
		return x.Geometry
	}
	return nil
}

// A bounding box for geospatial queries.
type BoundingBox struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bottom-left corner.
	BottomLeft *GeoPoint `protobuf:"bytes,1,opt,name=bottom_left,json=bottomLeft,proto3" json:"bottom_left,omitempty"`
	// Top-right corner.
	TopRight      *GeoPoint `protobuf:"bytes,2,opt,name=top_right,json=topRight,proto3" json:"top_right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundingBox) Reset() {
	*x = BoundingBox{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundingBox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundingBox) ProtoMessage() {}

func (x *BoundingBox) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundingBox.ProtoReflect.Descriptor instead.
func (*BoundingBox) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{8}
}

func (x *BoundingBox) GetBottomLeft() *GeoPoint {
	if x != nil {
		return x.BottomLeft
	}
	return nil
}

func (x *BoundingBox) GetTopRight() *GeoPoint {
	if x != nil {
		return x.TopRight
	}
	return nil
}

// A polygon for geospatial queries.
type Polygon struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The coordinates of the polygon's exterior ring.
	// The first and last points should be the same to close the polygon.
	Coordinates   []*GeoPoint `protobuf:"bytes,1,rep,name=coordinates,proto3" json:"coordinates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Polygon) Reset() {
	*x = Polygon{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Polygon) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Polygon) ProtoMessage() {}

func (x *Polygon) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Polygon.ProtoReflect.Descriptor instead.
func (*Polygon) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{9}
}

func (x *Polygon) GetCoordinates() []*GeoPoint {
	if x != nil {
		return x.Coordinates
	}
	return nil
}

// A circle for geospatial queries.
type Circle struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The center point.
	Center *GeoPoint `protobuf:"bytes,1,opt,name=center,proto3" json:"center,omitempty"`
	// The radius in radians (for $centerSphere).
	Radius        float64 `protobuf:"fixed64,2,opt,name=radius,proto3" json:"radius,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Circle) Reset() {
	*x = Circle{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Circle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Circle) ProtoMessage() {}

func (x *Circle) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Circle.ProtoReflect.Descriptor instead.
func (*Circle) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{10}
}

func (x *Circle) GetCenter() *GeoPoint {
	if x != nil {
		return x.Center
	}
	return nil
}

func (x *Circle) GetRadius() float64 {
	if x != nil {
		return x.Radius
	}
	return 0
}

// GeoJSON geometry for advanced geospatial queries.
type GeoJSON struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GeoJSON type (Point, LineString, Polygon, etc.).
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The coordinates (structure depends on type).
	Coordinates   *Value `protobuf:"bytes,2,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoJSON) Reset() {
	*x = GeoJSON{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoJSON) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoJSON) ProtoMessage() {}

func (x *GeoJSON) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoJSON.ProtoReflect.Descriptor instead.
func (*GeoJSON) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{11}
}

func (x *GeoJSON) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *GeoJSON) GetCoordinates() *Value {
	if x != nil {
		return x.Coordinates
	}
	return nil
}

// Index hint for query optimization.
type IndexHint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of hint.
	//
	// Types that are valid to be assigned to HintType:
	//
	//	*IndexHint_IndexName
	//	*IndexHint_IndexKeys
	HintType      isIndexHint_HintType `protobuf_oneof:"hint_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexHint) Reset() {
	*x = IndexHint{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexHint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexHint) ProtoMessage() {}

func (x *IndexHint) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexHint.ProtoReflect.Descriptor instead.
func (*IndexHint) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{12}
}

func (x *IndexHint) GetHintType() isIndexHint_HintType {
	if x != nil {
		return x.HintType
	}
	return nil
}

func (x *IndexHint) GetIndexName() string {
	if x != nil {
		if x, ok := x.HintType.(*IndexHint_IndexName); ok {
			return x.IndexName
		}
	}
	return ""
}

func (x *IndexHint) GetIndexKeys() *MapValue {
	if x != nil {
		if x, ok := x.HintType.(*IndexHint_IndexKeys); ok {
			return x.IndexKeys
		}
	}
	return nil
}

type isIndexHint_HintType interface {
	isIndexHint_HintType()
}

type IndexHint_IndexName struct {
	// The name of the index to use.
	IndexName string `protobuf:"bytes,1,opt,name=index_name,json=indexName,proto3,oneof"`
}

type IndexHint_IndexKeys struct {
	// The index keys to match.
	IndexKeys *MapValue `protobuf:"bytes,2,opt,name=index_keys,json=indexKeys,proto3,oneof"`
}

func (*IndexHint_IndexName) isIndexHint_HintType() {}

func (*IndexHint_IndexKeys) isIndexHint_HintType() {}

// Read preference for replica set queries.
type ReadPreference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The read preference mode.
	Mode ReadPreference_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=mongorpc.v1.ReadPreference_Mode" json:"mode,omitempty"`
	// Tag sets for filtering replica set members.
	TagSets []*MapValue `protobuf:"bytes,2,rep,name=tag_sets,json=tagSets,proto3" json:"tag_sets,omitempty"`
	// Maximum staleness in seconds.
	MaxStalenessSeconds int64 `protobuf:"varint,3,opt,name=max_staleness_seconds,json=maxStalenessSeconds,proto3" json:"max_staleness_seconds,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ReadPreference) Reset() {
	*x = ReadPreference{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadPreference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadPreference) ProtoMessage() {}

func (x *ReadPreference) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadPreference.ProtoReflect.Descriptor instead.
func (*ReadPreference) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{13}
}

func (x *ReadPreference) GetMode() ReadPreference_Mode {
	if x != nil {
		return x.Mode
	}
	return ReadPreference_MODE_UNSPECIFIED
}

func (x *ReadPreference) GetTagSets() []*MapValue {
	if x != nil {
		return x.TagSets
	}
	return nil
}

func (x *ReadPreference) GetMaxStalenessSeconds() int64 {
	if x != nil {
		return x.MaxStalenessSeconds
	}
	return 0
}

// Collation for string comparison.
type Collation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ICU locale string (e.g., "en_US", "fr").
	Locale string `protobuf:"bytes,1,opt,name=locale,proto3" json:"locale,omitempty"`
	// Whether comparison is case-sensitive.
	CaseLevel bool `protobuf:"varint,2,opt,name=case_level,json=caseLevel,proto3" json:"case_level,omitempty"`
	// The case ordering (upper vs lower first).
	CaseFirst string `protobuf:"bytes,3,opt,name=case_first,json=caseFirst,proto3" json:"case_first,omitempty"`
	// Comparison strength (1-5).
	Strength int32 `protobuf:"varint,4,opt,name=strength,proto3" json:"strength,omitempty"`
	// Whether to compare numeric strings as numbers.
	NumericOrdering bool `protobuf:"varint,5,opt,name=numeric_ordering,json=numericOrdering,proto3" json:"numeric_ordering,omitempty"`
	// Alternate handling for spaces and punctuation.
	Alternate string `protobuf:"bytes,6,opt,name=alternate,proto3" json:"alternate,omitempty"`
	// Maximum variable characters.
	MaxVariable string `protobuf:"bytes,7,opt,name=max_variable,json=maxVariable,proto3" json:"max_variable,omitempty"`
	// Whether to normalize strings.
	Normalization bool `protobuf:"varint,8,opt,name=normalization,proto3" json:"normalization,omitempty"`
	// Whether order is backward.
	Backwards     bool `protobuf:"varint,9,opt,name=backwards,proto3" json:"backwards,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Collation) Reset() {
	*x = Collation{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Collation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Collation) ProtoMessage() {}

func (x *Collation) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Collation.ProtoReflect.Descriptor instead.
func (*Collation) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{14}
}

func (x *Collation) GetLocale() string {
	if x != nil {
		return x.Locale
	}
	return ""
}

func (x *Collation) GetCaseLevel() bool {
	if x != nil {
		return x.CaseLevel
	}
	return false
}

func (x *Collation) GetCaseFirst() string {
	if x != nil {
		return x.CaseFirst
	}
	return ""
}

func (x *Collation) GetStrength() int32 {
	if x != nil {
		return x.Strength
	}
	return 0
}

func (x *Collation) GetNumericOrdering() bool {
	if x != nil {
		return x.NumericOrdering
	}
	return false
}

func (x *Collation) GetAlternate() string {
	if x != nil {
		return x.Alternate
	}
	return ""
}

func (x *Collation) GetMaxVariable() string {
	if x != nil {
		return x.MaxVariable
	}
	return ""
}

func (x *Collation) GetNormalization() bool {
	if x != nil {
		return x.Normalization
	}
	return false
}

func (x *Collation) GetBackwards() bool {
	if x != nil {
		return x.Backwards
	}
	return false
}

// A cursor position in query results.
type Cursor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The values that represent the cursor position.
	// These correspond to the sort fields in the query.
	Values []*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	// The document ID at this cursor position.
	DocumentId *ObjectId `protobuf:"bytes,2,opt,name=document_id,json=documentId,proto3" json:"document_id,omitempty"`
	// Whether this cursor is inclusive (before=false) or exclusive (before=true).
	Before        bool `protobuf:"varint,3,opt,name=before,proto3" json:"before,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cursor) Reset() {
	*x = Cursor{}
	mi := &file_mongorpc_v1_query_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cursor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cursor) ProtoMessage() {}

func (x *Cursor) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_query_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cursor.ProtoReflect.Descriptor instead.
func (*Cursor) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_query_proto_rawDescGZIP(), []int{15}
}

func (x *Cursor) GetValues() []*Value {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *Cursor) GetDocumentId() *ObjectId {
	if x != nil {
		return x.DocumentId
	}
	return nil
}

func (x *Cursor) GetBefore() bool {
	if x != nil {
		return x.Before
	}
	return false
}

var File_mongorpc_v1_query_proto protoreflect.FileDescriptor

const file_mongorpc_v1_query_proto_rawDesc = "" +
	"\n" +
	"\x17mongorpc/v1/query.proto\x12\vmongorpc.v1\x1a\x17mongorpc/v1/value.proto\x1a\x1amongorpc/v1/document.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xc4\x03\n" +
	"\x05Query\x12\x1a\n" +
	"\bdatabase\x18\x01 \x01(\tR\bdatabase\x12\x1e\n" +
	"\n" +
	"collection\x18\x02 \x01(\tR\n" +
	"collection\x12+\n" +
	"\x06filter\x18\x03 \x01(\v2\x13.mongorpc.v1.FilterR\x06filter\x127\n" +
	"\n" +
	"projection\x18\x04 \x01(\v2\x17.mongorpc.v1.ProjectionR\n" +
	"projection\x12*\n" +
	"\x04sort\x18\x05 \x03(\v2\x16.mongorpc.v1.SortOrderR\x04sort\x12\x12\n" +
	"\x04skip\x18\x06 \x01(\x03R\x04skip\x121\n" +
	"\x05limit\x18\a \x01(\v2\x1b.google.protobuf.Int64ValueR\x05limit\x12*\n" +
	"\x04hint\x18\b \x01(\v2\x16.mongorpc.v1.IndexHintR\x04hint\x12D\n" +
	"\x0fread_preference\x18\t \x01(\v2\x1b.mongorpc.v1.ReadPreferenceR\x0ereadPreference\x124\n" +
	"\tcollation\x18\n" +
	" \x01(\v2\x16.mongorpc.v1.CollationR\tcollation\"\xb2\x01\n" +
	"\x06Filter\x12<\n" +
	"\tcomposite\x18\x01 \x01(\v2\x1c.mongorpc.v1.CompositeFilterH\x00R\tcomposite\x120\n" +
	"\x05field\x18\x02 \x01(\v2\x18.mongorpc.v1.FieldFilterH\x00R\x05field\x12)\n" +
	"\x03raw\x18\x03 \x01(\v2\x15.mongorpc.v1.MapValueH\x00R\x03rawB\r\n" +
	"\vfilter_type\"\xb7\x01\n" +
	"\x0fCompositeFilter\x125\n" +
	"\x02op\x18\x01 \x01(\x0e2%.mongorpc.v1.CompositeFilter.OperatorR\x02op\x12-\n" +
	"\afilters\x18\x02 \x03(\v2\x13.mongorpc.v1.FilterR\afilters\">\n" +
	"\bOperator\x12\x18\n" +
	"\x14OPERATOR_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03AND\x10\x01\x12\x06\n" +
	"\x02OR\x10\x02\x12\a\n" +
	"\x03NOR\x10\x03\"\xef\x03\n" +
	"\vFieldFilter\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x121\n" +
	"\x02op\x18\x02 \x01(\x0e2!.mongorpc.v1.FieldFilter.OperatorR\x02op\x12(\n" +
	"\x05value\x18\x03 \x01(\v2\x12.mongorpc.v1.ValueR\x05value\"\xec\x02\n" +
	"\bOperator\x12\x18\n" +
	"\x14OPERATOR_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05EQUAL\x10\x01\x12\r\n" +
	"\tNOT_EQUAL\x10\x02\x12\r\n" +
	"\tLESS_THAN\x10\x03\x12\x16\n" +
	"\x12LESS_THAN_OR_EQUAL\x10\x04\x12\x10\n" +
	"\fGREATER_THAN\x10\x05\x12\x19\n" +
	"\x15GREATER_THAN_OR_EQUAL\x10\x06\x12\x06\n" +
	"\x02IN\x10\a\x12\n" +
	"\n" +
	"\x06NOT_IN\x10\b\x12\x12\n" +
	"\x0eARRAY_CONTAINS\x10\t\x12\x16\n" +
	"\x12ARRAY_CONTAINS_ANY\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06EXISTS\x10\v\x12\x0e\n" +
	"\n" +
	"NOT_EXISTS\x10\f\x12\b\n" +
	"\x04TYPE\x10\r\x12\t\n" +
	"\x05REGEX\x10\x0e\x12\b\n" +
	"\x04TEXT\x10\x0f\x12\a\n" +
	"\x03MOD\x10\x10\x12\b\n" +
	"\x04SIZE\x10\x11\x12\x12\n" +
	"\x0eBITS_ALL_CLEAR\x10\x12\x12\x10\n" +
	"\fBITS_ALL_SET\x10\x13\x12\x12\n" +
	"\x0eBITS_ANY_CLEAR\x10\x14\x12\x10\n" +
	"\fBITS_ANY_SET\x10\x15\"\xb3\x01\n" +
	"\tGeoFilter\x12*\n" +
	"\x04near\x18\x01 \x01(\v2\x14.mongorpc.v1.GeoNearH\x00R\x04near\x120\n" +
	"\x06within\x18\x02 \x01(\v2\x16.mongorpc.v1.GeoWithinH\x00R\x06within\x12<\n" +
	"\n" +
	"intersects\x18\x03 \x01(\v2\x1a.mongorpc.v1.GeoIntersectsH\x00R\n" +
	"intersectsB\n" +
	"\n" +
	"\bgeo_type\"\xb0\x01\n" +
	"\aGeoNear\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12+\n" +
	"\x05point\x18\x02 \x01(\v2\x15.mongorpc.v1.GeoPointR\x05point\x12!\n" +
	"\fmax_distance\x18\x03 \x01(\x01R\vmaxDistance\x12!\n" +
	"\fmin_distance\x18\x04 \x01(\x01R\vminDistance\x12\x1c\n" +
	"\tspherical\x18\x05 \x01(\bR\tspherical\"\xbc\x01\n" +
	"\tGeoWithin\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12,\n" +
	"\x03box\x18\x02 \x01(\v2\x18.mongorpc.v1.BoundingBoxH\x00R\x03box\x120\n" +
	"\apolygon\x18\x03 \x01(\v2\x14.mongorpc.v1.PolygonH\x00R\apolygon\x12-\n" +
	"\x06circle\x18\x04 \x01(\v2\x13.mongorpc.v1.CircleH\x00R\x06circleB\n" +
	"\n" +
	"\bgeometry\"W\n" +
	"\rGeoIntersects\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x120\n" +
	"\bgeometry\x18\x02 \x01(\v2\x14.mongorpc.v1.GeoJSONR\bgeometry\"y\n" +
	"\vBoundingBox\x126\n" +
	"\vbottom_left\x18\x01 \x01(\v2\x15.mongorpc.v1.GeoPointR\n" +
	"bottomLeft\x122\n" +
	"\ttop_right\x18\x02 \x01(\v2\x15.mongorpc.v1.GeoPointR\btopRight\"B\n" +
	"\aPolygon\x127\n" +
	"\vcoordinates\x18\x01 \x03(\v2\x15.mongorpc.v1.GeoPointR\vcoordinates\"O\n" +
	"\x06Circle\x12-\n" +
	"\x06center\x18\x01 \x01(\v2\x15.mongorpc.v1.GeoPointR\x06center\x12\x16\n" +
	"\x06radius\x18\x02 \x01(\x01R\x06radius\"S\n" +
	"\aGeoJSON\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x124\n" +
	"\vcoordinates\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueR\vcoordinates\"q\n" +
	"\tIndexHint\x12\x1f\n" +
	"\n" +
	"index_name\x18\x01 \x01(\tH\x00R\tindexName\x126\n" +
	"\n" +
	"index_keys\x18\x02 \x01(\v2\x15.mongorpc.v1.MapValueH\x00R\tindexKeysB\v\n" +
	"\thint_type\"\xa3\x02\n" +
	"\x0eReadPreference\x124\n" +
	"\x04mode\x18\x01 \x01(\x0e2 .mongorpc.v1.ReadPreference.ModeR\x04mode\x120\n" +
	"\btag_sets\x18\x02 \x03(\v2\x15.mongorpc.v1.MapValueR\atagSets\x122\n" +
	"\x15max_staleness_seconds\x18\x03 \x01(\x03R\x13maxStalenessSeconds\"u\n" +
	"\x04Mode\x12\x14\n" +
	"\x10MODE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\x15\n" +
	"\x11PRIMARY_PREFERRED\x10\x02\x12\r\n" +
	"\tSECONDARY\x10\x03\x12\x17\n" +
	"\x13SECONDARY_PREFERRED\x10\x04\x12\v\n" +
	"\aNEAREST\x10\x05\"\xad\x02\n" +
	"\tCollation\x12\x16\n" +
	"\x06locale\x18\x01 \x01(\tR\x06locale\x12\x1d\n" +
	"\n" +
	"case_level\x18\x02 \x01(\bR\tcaseLevel\x12\x1d\n" +
	"\n" +
	"case_first\x18\x03 \x01(\tR\tcaseFirst\x12\x1a\n" +
	"\bstrength\x18\x04 \x01(\x05R\bstrength\x12)\n" +
	"\x10numeric_ordering\x18\x05 \x01(\bR\x0fnumericOrdering\x12\x1c\n" +
	"\talternate\x18\x06 \x01(\tR\talternate\x12!\n" +
	"\fmax_variable\x18\a \x01(\tR\vmaxVariable\x12$\n" +
	"\rnormalization\x18\b \x01(\bR\rnormalization\x12\x1c\n" +
	"\tbackwards\x18\t \x01(\bR\tbackwards\"\x84\x01\n" +
	"\x06Cursor\x12*\n" +
	"\x06values\x18\x01 \x03(\v2\x12.mongorpc.v1.ValueR\x06values\x126\n" +
	"\vdocument_id\x18\x02 \x01(\v2\x15.mongorpc.v1.ObjectIdR\n" +
	"documentId\x12\x16\n" +
	"\x06before\x18\x03 \x01(\bR\x06beforeB\xa3\x01\n" +
	"\x0fcom.mongorpc.v1B\n" +
	"QueryProtoP\x01Z7github.com/mongorpc/mongorpc/gen/mongorpc/v1;mongorpcv1\xa2\x02\x03MXX\xaa\x02\vMongorpc.V1\xca\x02\vMongorpc\\V1\xe2\x02\x17Mongorpc\\V1\\GPBMetadata\xea\x02\fMongorpc::V1b\x06proto3"

var (
	file_mongorpc_v1_query_proto_rawDescOnce sync.Once
	file_mongorpc_v1_query_proto_rawDescData []byte
)

func file_mongorpc_v1_query_proto_rawDescGZIP() []byte {
	file_mongorpc_v1_query_proto_rawDescOnce.Do(func() {
		file_mongorpc_v1_query_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_mongorpc_v1_query_proto_rawDesc), len(file_mongorpc_v1_query_proto_rawDesc)))
	})
	return file_mongorpc_v1_query_proto_rawDescData
}

var file_mongorpc_v1_query_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_mongorpc_v1_query_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_mongorpc_v1_query_proto_goTypes = []any{
	(CompositeFilter_Operator)(0), // 0: mongorpc.v1.CompositeFilter.Operator
	(FieldFilter_Operator)(0),     // 1: mongorpc.v1.FieldFilter.Operator
	(ReadPreference_Mode)(0),      // 2: mongorpc.v1.ReadPreference.Mode
	(*Query)(nil),                 // 3: mongorpc.v1.Query
	(*Filter)(nil),                // 4: mongorpc.v1.Filter
	(*CompositeFilter)(nil),       // 5: mongorpc.v1.CompositeFilter
	(*FieldFilter)(nil),           // 6: mongorpc.v1.FieldFilter
	(*GeoFilter)(nil),             // 7: mongorpc.v1.GeoFilter
	(*GeoNear)(nil),               // 8: mongorpc.v1.GeoNear
	(*GeoWithin)(nil),             // 9: mongorpc.v1.GeoWithin
	(*GeoIntersects)(nil),         // 10: mongorpc.v1.GeoIntersects
	(*BoundingBox)(nil),           // 11: mongorpc.v1.BoundingBox
	(*Polygon)(nil),               // 12: mongorpc.v1.Polygon
	(*Circle)(nil),                // 13: mongorpc.v1.Circle
	(*GeoJSON)(nil),               // 14: mongorpc.v1.GeoJSON
	(*IndexHint)(nil),             // 15: mongorpc.v1.IndexHint
	(*ReadPreference)(nil),        // 16: mongorpc.v1.ReadPreference
	(*Collation)(nil),             // 17: mongorpc.v1.Collation
	(*Cursor)(nil),                // 18: mongorpc.v1.Cursor
	(*Projection)(nil),            // 19: mongorpc.v1.Projection
	(*SortOrder)(nil),             // 20: mongorpc.v1.SortOrder
	(*wrapperspb.Int64Value)(nil), // 21: google.protobuf.Int64Value
	(*MapValue)(nil),              // 22: mongorpc.v1.MapValue
	(*Value)(nil),                 // 23: mongorpc.v1.Value
	(*GeoPoint)(nil),              // 24: mongorpc.v1.GeoPoint
	(*ObjectId)(nil),              // 25: mongorpc.v1.ObjectId
}
var file_mongorpc_v1_query_proto_depIdxs = []int32{
	4,  // 0: mongorpc.v1.Query.filter:type_name -> mongorpc.v1.Filter
	19, // 1: mongorpc.v1.Query.projection:type_name -> mongorpc.v1.Projection
	20, // 2: mongorpc.v1.Query.sort:type_name -> mongorpc.v1.SortOrder
	21, // 3: mongorpc.v1.Query.limit:type_name -> google.protobuf.Int64Value
	15, // 4: mongorpc.v1.Query.hint:type_name -> mongorpc.v1.IndexHint
	16, // 5: mongorpc.v1.Query.read_preference:type_name -> mongorpc.v1.ReadPreference
	17, // 6: mongorpc.v1.Query.collation:type_name -> mongorpc.v1.Collation
	5,  // 7: mongorpc.v1.Filter.composite:type_name -> mongorpc.v1.CompositeFilter
	6,  // 8: mongorpc.v1.Filter.field:type_name -> mongorpc.v1.FieldFilter
	22, // 9: mongorpc.v1.Filter.raw:type_name -> mongorpc.v1.MapValue
	0,  // 10: mongorpc.v1.CompositeFilter.op:type_name -> mongorpc.v1.CompositeFilter.Operator
	4,  // 11: mongorpc.v1.CompositeFilter.filters:type_name -> mongorpc.v1.Filter
	1,  // 12: mongorpc.v1.FieldFilter.op:type_name -> mongorpc.v1.FieldFilter.Operator
	23, // 13: mongorpc.v1.FieldFilter.value:type_name -> mongorpc.v1.Value
	8,  // 14: mongorpc.v1.GeoFilter.near:type_name -> mongorpc.v1.GeoNear
	9,  // 15: mongorpc.v1.GeoFilter.within:type_name -> mongorpc.v1.GeoWithin
	10, // 16: mongorpc.v1.GeoFilter.intersects:type_name -> mongorpc.v1.GeoIntersects
	24, // 17: mongorpc.v1.GeoNear.point:type_name -> mongorpc.v1.GeoPoint
	11, // 18: mongorpc.v1.GeoWithin.box:type_name -> mongorpc.v1.BoundingBox
	12, // 19: mongorpc.v1.GeoWithin.polygon:type_name -> mongorpc.v1.Polygon
	13, // 20: mongorpc.v1.GeoWithin.circle:type_name -> mongorpc.v1.Circle
	14, // 21: mongorpc.v1.GeoIntersects.geometry:type_name -> mongorpc.v1.GeoJSON
	24, // 22: mongorpc.v1.BoundingBox.bottom_left:type_name -> mongorpc.v1.GeoPoint
	24, // 23: mongorpc.v1.BoundingBox.top_right:type_name -> mongorpc.v1.GeoPoint
	24, // 24: mongorpc.v1.Polygon.coordinates:type_name -> mongorpc.v1.GeoPoint
	24, // 25: mongorpc.v1.Circle.center:type_name -> mongorpc.v1.GeoPoint
	23, // 26: mongorpc.v1.GeoJSON.coordinates:type_name -> mongorpc.v1.Value
	22, // 27: mongorpc.v1.IndexHint.index_keys:type_name -> mongorpc.v1.MapValue
	2,  // 28: mongorpc.v1.ReadPreference.mode:type_name -> mongorpc.v1.ReadPreference.Mode
	22, // 29: mongorpc.v1.ReadPreference.tag_sets:type_name -> mongorpc.v1.MapValue
	23, // 30: mongorpc.v1.Cursor.values:type_name -> mongorpc.v1.Value
	25, // 31: mongorpc.v1.Cursor.document_id:type_name -> mongorpc.v1.ObjectId
	32, // [32:32] is the sub-list for method output_type
	32, // [32:32] is the sub-list for method input_type
	32, // [32:32] is the sub-list for extension type_name
	32, // [32:32] is the sub-list for extension extendee
	0,  // [0:32] is the sub-list for field type_name
}

func init() { file_mongorpc_v1_query_proto_init() }
func file_mongorpc_v1_query_proto_init() {
	if File_mongorpc_v1_query_proto != nil {
		return
	}
	file_mongorpc_v1_value_proto_init()
	file_mongorpc_v1_document_proto_init()
	file_mongorpc_v1_query_proto_msgTypes[1].OneofWrappers = []any{
		(*Filter_Composite)(nil),
		(*Filter_Field)(nil),
		(*Filter_Raw)(nil),
	}
	file_mongorpc_v1_query_proto_msgTypes[4].OneofWrappers = []any{
		(*GeoFilter_Near)(nil),
		(*GeoFilter_Within)(nil),
		(*GeoFilter_Intersects)(nil),
	}
	file_mongorpc_v1_query_proto_msgTypes[6].OneofWrappers = []any{
		(*GeoWithin_Box)(nil),
		(*GeoWithin_Polygon)(nil),
		(*GeoWithin_Circle)(nil),
	}
	file_mongorpc_v1_query_proto_msgTypes[12].OneofWrappers = []any{
		(*IndexHint_IndexName)(nil),
		(*IndexHint_IndexKeys)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_mongorpc_v1_query_proto_rawDesc), len(file_mongorpc_v1_query_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mongorpc_v1_query_proto_goTypes,
		DependencyIndexes: file_mongorpc_v1_query_proto_depIdxs,
		EnumInfos:         file_mongorpc_v1_query_proto_enumTypes,
		MessageInfos:      file_mongorpc_v1_query_proto_msgTypes,
	}.Build()
	File_mongorpc_v1_query_proto = out.File
	file_mongorpc_v1_query_proto_goTypes = nil
	file_mongorpc_v1_query_proto_depIdxs = nil
}
