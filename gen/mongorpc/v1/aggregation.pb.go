// Copyright 2024 MongoRPC
// SPDX-License-Identifier: Apache-2.0
//
// Aggregation pipeline definitions for MongoRPC.
// This file defines the aggregation framework for complex data processing.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: mongorpc/v1/aggregation.proto

package mongorpcv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The accumulator type.
type Accumulator_Type int32

const (
	// Unspecified.
	Accumulator_TYPE_UNSPECIFIED Accumulator_Type = 0
	// Sum of values ($sum).
	Accumulator_SUM Accumulator_Type = 1
	// Average of values ($avg).
	Accumulator_AVG Accumulator_Type = 2
	// First value ($first).
	Accumulator_FIRST Accumulator_Type = 3
	// Last value ($last).
	Accumulator_LAST Accumulator_Type = 4
	// Maximum value ($max).
	Accumulator_MAX Accumulator_Type = 5
	// Minimum value ($min).
	Accumulator_MIN Accumulator_Type = 6
	// Push to array ($push).
	Accumulator_PUSH Accumulator_Type = 7
	// Add to set ($addToSet).
	Accumulator_ADD_TO_SET Accumulator_Type = 8
	// Count documents ($count / $sum: 1).
	Accumulator_COUNT Accumulator_Type = 9
	// Standard deviation (population) ($stdDevPop).
	Accumulator_STD_DEV_POP Accumulator_Type = 10
	// Standard deviation (sample) ($stdDevSamp).
	Accumulator_STD_DEV_SAMP Accumulator_Type = 11
	// Merge objects ($mergeObjects).
	Accumulator_MERGE_OBJECTS Accumulator_Type = 12
	// Top N documents ($topN).
	Accumulator_TOP_N Accumulator_Type = 13
	// Bottom N documents ($bottomN).
	Accumulator_BOTTOM_N Accumulator_Type = 14
	// First N elements ($firstN).
	Accumulator_FIRST_N Accumulator_Type = 15
	// Last N elements ($lastN).
	Accumulator_LAST_N Accumulator_Type = 16
	// Max N elements ($maxN).
	Accumulator_MAX_N Accumulator_Type = 17
	// Min N elements ($minN).
	Accumulator_MIN_N Accumulator_Type = 18
)

// Enum value maps for Accumulator_Type.
var (
	Accumulator_Type_name = map[int32]string{
		0:  "TYPE_UNSPECIFIED",
		1:  "SUM",
		2:  "AVG",
		3:  "FIRST",
		4:  "LAST",
		5:  "MAX",
		6:  "MIN",
		7:  "PUSH",
		8:  "ADD_TO_SET",
		9:  "COUNT",
		10: "STD_DEV_POP",
		11: "STD_DEV_SAMP",
		12: "MERGE_OBJECTS",
		13: "TOP_N",
		14: "BOTTOM_N",
		15: "FIRST_N",
		16: "LAST_N",
		17: "MAX_N",
		18: "MIN_N",
	}
	Accumulator_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"SUM":              1,
		"AVG":              2,
		"FIRST":            3,
		"LAST":             4,
		"MAX":              5,
		"MIN":              6,
		"PUSH":             7,
		"ADD_TO_SET":       8,
		"COUNT":            9,
		"STD_DEV_POP":      10,
		"STD_DEV_SAMP":     11,
		"MERGE_OBJECTS":    12,
		"TOP_N":            13,
		"BOTTOM_N":         14,
		"FIRST_N":          15,
		"LAST_N":           16,
		"MAX_N":            17,
		"MIN_N":            18,
	}
)

func (x Accumulator_Type) Enum() *Accumulator_Type {
	p := new(Accumulator_Type)
	*p = x
	return p
}

func (x Accumulator_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Accumulator_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_mongorpc_v1_aggregation_proto_enumTypes[0].Descriptor()
}

func (Accumulator_Type) Type() protoreflect.EnumType {
	return &file_mongorpc_v1_aggregation_proto_enumTypes[0]
}

func (x Accumulator_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Accumulator_Type.Descriptor instead.
func (Accumulator_Type) EnumDescriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{6, 0}
}

// An aggregation pipeline.
// Pipelines process documents through a sequence of stages.
type AggregationPipeline struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The database containing the collection.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// The collection to aggregate.
	Collection string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
	// The pipeline stages to execute in order.
	Stages []*PipelineStage `protobuf:"bytes,3,rep,name=stages,proto3" json:"stages,omitempty"`
	// Options for the aggregation.
	Options       *AggregationOptions `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregationPipeline) Reset() {
	*x = AggregationPipeline{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationPipeline) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationPipeline) ProtoMessage() {}

func (x *AggregationPipeline) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationPipeline.ProtoReflect.Descriptor instead.
func (*AggregationPipeline) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{0}
}

func (x *AggregationPipeline) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *AggregationPipeline) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *AggregationPipeline) GetStages() []*PipelineStage {
	if x != nil {
		return x.Stages
	}
	return nil
}

func (x *AggregationPipeline) GetOptions() *AggregationOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// A single stage in an aggregation pipeline.
type PipelineStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of stage.
	//
	// Types that are valid to be assigned to StageType:
	//
	//	*PipelineStage_Match
	//	*PipelineStage_Project
	//	*PipelineStage_Group
	//	*PipelineStage_Sort
	//	*PipelineStage_Limit
	//	*PipelineStage_Skip
	//	*PipelineStage_Unwind
	//	*PipelineStage_Lookup
	//	*PipelineStage_AddFields
	//	*PipelineStage_Set
	//	*PipelineStage_Unset
	//	*PipelineStage_ReplaceRoot
	//	*PipelineStage_Count
	//	*PipelineStage_Facet
	//	*PipelineStage_Bucket
	//	*PipelineStage_BucketAuto
	//	*PipelineStage_Sample
	//	*PipelineStage_Out
	//	*PipelineStage_Merge
	//	*PipelineStage_GeoNear
	//	*PipelineStage_GraphLookup
	//	*PipelineStage_UnionWith
	//	*PipelineStage_Raw
	StageType     isPipelineStage_StageType `protobuf_oneof:"stage_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PipelineStage) Reset() {
	*x = PipelineStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PipelineStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PipelineStage) ProtoMessage() {}

func (x *PipelineStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PipelineStage.ProtoReflect.Descriptor instead.
func (*PipelineStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{1}
}

func (x *PipelineStage) GetStageType() isPipelineStage_StageType {
	if x != nil {
		return x.StageType
	}
	return nil
}

func (x *PipelineStage) GetMatch() *MatchStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Match); ok {
			return x.Match
		}
	}
	return nil
}

func (x *PipelineStage) GetProject() *ProjectStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Project); ok {
			return x.Project
		}
	}
	return nil
}

func (x *PipelineStage) GetGroup() *GroupStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Group); ok {
			return x.Group
		}
	}
	return nil
}

func (x *PipelineStage) GetSort() *SortStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Sort); ok {
			return x.Sort
		}
	}
	return nil
}

func (x *PipelineStage) GetLimit() *LimitStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Limit); ok {
			return x.Limit
		}
	}
	return nil
}

func (x *PipelineStage) GetSkip() *SkipStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Skip); ok {
			return x.Skip
		}
	}
	return nil
}

func (x *PipelineStage) GetUnwind() *UnwindStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Unwind); ok {
			return x.Unwind
		}
	}
	return nil
}

func (x *PipelineStage) GetLookup() *LookupStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Lookup); ok {
			return x.Lookup
		}
	}
	return nil
}

func (x *PipelineStage) GetAddFields() *AddFieldsStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_AddFields); ok {
			return x.AddFields
		}
	}
	return nil
}

func (x *PipelineStage) GetSet() *AddFieldsStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Set); ok {
			return x.Set
		}
	}
	return nil
}

func (x *PipelineStage) GetUnset() *UnsetStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Unset); ok {
			return x.Unset
		}
	}
	return nil
}

func (x *PipelineStage) GetReplaceRoot() *ReplaceRootStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_ReplaceRoot); ok {
			return x.ReplaceRoot
		}
	}
	return nil
}

func (x *PipelineStage) GetCount() *CountStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Count); ok {
			return x.Count
		}
	}
	return nil
}

func (x *PipelineStage) GetFacet() *FacetStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Facet); ok {
			return x.Facet
		}
	}
	return nil
}

func (x *PipelineStage) GetBucket() *BucketStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Bucket); ok {
			return x.Bucket
		}
	}
	return nil
}

func (x *PipelineStage) GetBucketAuto() *BucketAutoStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_BucketAuto); ok {
			return x.BucketAuto
		}
	}
	return nil
}

func (x *PipelineStage) GetSample() *SampleStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Sample); ok {
			return x.Sample
		}
	}
	return nil
}

func (x *PipelineStage) GetOut() *OutStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Out); ok {
			return x.Out
		}
	}
	return nil
}

func (x *PipelineStage) GetMerge() *MergeStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Merge); ok {
			return x.Merge
		}
	}
	return nil
}

func (x *PipelineStage) GetGeoNear() *GeoNearStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_GeoNear); ok {
			return x.GeoNear
		}
	}
	return nil
}

func (x *PipelineStage) GetGraphLookup() *GraphLookupStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_GraphLookup); ok {
			return x.GraphLookup
		}
	}
	return nil
}

func (x *PipelineStage) GetUnionWith() *UnionWithStage {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_UnionWith); ok {
			return x.UnionWith
		}
	}
	return nil
}

func (x *PipelineStage) GetRaw() *MapValue {
	if x != nil {
		if x, ok := x.StageType.(*PipelineStage_Raw); ok {
			return x.Raw
		}
	}
	return nil
}

type isPipelineStage_StageType interface {
	isPipelineStage_StageType()
}

type PipelineStage_Match struct {
	// $match - Filter documents.
	Match *MatchStage `protobuf:"bytes,1,opt,name=match,proto3,oneof"`
}

type PipelineStage_Project struct {
	// $project - Reshape documents.
	Project *ProjectStage `protobuf:"bytes,2,opt,name=project,proto3,oneof"`
}

type PipelineStage_Group struct {
	// $group - Group documents and calculate aggregates.
	Group *GroupStage `protobuf:"bytes,3,opt,name=group,proto3,oneof"`
}

type PipelineStage_Sort struct {
	// $sort - Sort documents.
	Sort *SortStage `protobuf:"bytes,4,opt,name=sort,proto3,oneof"`
}

type PipelineStage_Limit struct {
	// $limit - Limit number of documents.
	Limit *LimitStage `protobuf:"bytes,5,opt,name=limit,proto3,oneof"`
}

type PipelineStage_Skip struct {
	// $skip - Skip documents.
	Skip *SkipStage `protobuf:"bytes,6,opt,name=skip,proto3,oneof"`
}

type PipelineStage_Unwind struct {
	// $unwind - Deconstruct arrays.
	Unwind *UnwindStage `protobuf:"bytes,7,opt,name=unwind,proto3,oneof"`
}

type PipelineStage_Lookup struct {
	// $lookup - Join with another collection.
	Lookup *LookupStage `protobuf:"bytes,8,opt,name=lookup,proto3,oneof"`
}

type PipelineStage_AddFields struct {
	// $addFields - Add new fields.
	AddFields *AddFieldsStage `protobuf:"bytes,9,opt,name=add_fields,json=addFields,proto3,oneof"`
}

type PipelineStage_Set struct {
	// $set - Alias for $addFields.
	Set *AddFieldsStage `protobuf:"bytes,10,opt,name=set,proto3,oneof"`
}

type PipelineStage_Unset struct {
	// $unset - Remove fields.
	Unset *UnsetStage `protobuf:"bytes,11,opt,name=unset,proto3,oneof"`
}

type PipelineStage_ReplaceRoot struct {
	// $replaceRoot - Replace the root document.
	ReplaceRoot *ReplaceRootStage `protobuf:"bytes,12,opt,name=replace_root,json=replaceRoot,proto3,oneof"`
}

type PipelineStage_Count struct {
	// $count - Count documents.
	Count *CountStage `protobuf:"bytes,13,opt,name=count,proto3,oneof"`
}

type PipelineStage_Facet struct {
	// $facet - Multiple pipelines in parallel.
	Facet *FacetStage `protobuf:"bytes,14,opt,name=facet,proto3,oneof"`
}

type PipelineStage_Bucket struct {
	// $bucket - Bucket documents by boundaries.
	Bucket *BucketStage `protobuf:"bytes,15,opt,name=bucket,proto3,oneof"`
}

type PipelineStage_BucketAuto struct {
	// $bucketAuto - Auto-bucket documents.
	BucketAuto *BucketAutoStage `protobuf:"bytes,16,opt,name=bucket_auto,json=bucketAuto,proto3,oneof"`
}

type PipelineStage_Sample struct {
	// $sample - Random sample of documents.
	Sample *SampleStage `protobuf:"bytes,17,opt,name=sample,proto3,oneof"`
}

type PipelineStage_Out struct {
	// $out - Write results to a collection.
	Out *OutStage `protobuf:"bytes,18,opt,name=out,proto3,oneof"`
}

type PipelineStage_Merge struct {
	// $merge - Merge results into a collection.
	Merge *MergeStage `protobuf:"bytes,19,opt,name=merge,proto3,oneof"`
}

type PipelineStage_GeoNear struct {
	// $geoNear - Geospatial query stage.
	GeoNear *GeoNearStage `protobuf:"bytes,20,opt,name=geo_near,json=geoNear,proto3,oneof"`
}

type PipelineStage_GraphLookup struct {
	// $graphLookup - Recursive lookup.
	GraphLookup *GraphLookupStage `protobuf:"bytes,21,opt,name=graph_lookup,json=graphLookup,proto3,oneof"`
}

type PipelineStage_UnionWith struct {
	// $unionWith - Union with another collection.
	UnionWith *UnionWithStage `protobuf:"bytes,22,opt,name=union_with,json=unionWith,proto3,oneof"`
}

type PipelineStage_Raw struct {
	// Raw stage for advanced/custom stages.
	Raw *MapValue `protobuf:"bytes,99,opt,name=raw,proto3,oneof"`
}

func (*PipelineStage_Match) isPipelineStage_StageType() {}

func (*PipelineStage_Project) isPipelineStage_StageType() {}

func (*PipelineStage_Group) isPipelineStage_StageType() {}

func (*PipelineStage_Sort) isPipelineStage_StageType() {}

func (*PipelineStage_Limit) isPipelineStage_StageType() {}

func (*PipelineStage_Skip) isPipelineStage_StageType() {}

func (*PipelineStage_Unwind) isPipelineStage_StageType() {}

func (*PipelineStage_Lookup) isPipelineStage_StageType() {}

func (*PipelineStage_AddFields) isPipelineStage_StageType() {}

func (*PipelineStage_Set) isPipelineStage_StageType() {}

func (*PipelineStage_Unset) isPipelineStage_StageType() {}

func (*PipelineStage_ReplaceRoot) isPipelineStage_StageType() {}

func (*PipelineStage_Count) isPipelineStage_StageType() {}

func (*PipelineStage_Facet) isPipelineStage_StageType() {}

func (*PipelineStage_Bucket) isPipelineStage_StageType() {}

func (*PipelineStage_BucketAuto) isPipelineStage_StageType() {}

func (*PipelineStage_Sample) isPipelineStage_StageType() {}

func (*PipelineStage_Out) isPipelineStage_StageType() {}

func (*PipelineStage_Merge) isPipelineStage_StageType() {}

func (*PipelineStage_GeoNear) isPipelineStage_StageType() {}

func (*PipelineStage_GraphLookup) isPipelineStage_StageType() {}

func (*PipelineStage_UnionWith) isPipelineStage_StageType() {}

func (*PipelineStage_Raw) isPipelineStage_StageType() {}

// $match stage - Filter documents.
type MatchStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The filter to apply.
	Filter        *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MatchStage) Reset() {
	*x = MatchStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MatchStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchStage) ProtoMessage() {}

func (x *MatchStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchStage.ProtoReflect.Descriptor instead.
func (*MatchStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{2}
}

func (x *MatchStage) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

// $project stage - Reshape documents.
type ProjectStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Field specifications.
	// Use 1 to include, 0 to exclude.
	// Use expressions for computed fields.
	Fields        map[string]*ProjectExpression `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectStage) Reset() {
	*x = ProjectStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectStage) ProtoMessage() {}

func (x *ProjectStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectStage.ProtoReflect.Descriptor instead.
func (*ProjectStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{3}
}

func (x *ProjectStage) GetFields() map[string]*ProjectExpression {
	if x != nil {
		return x.Fields
	}
	return nil
}

// A projection expression.
type ProjectExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ExpressionType:
	//
	//	*ProjectExpression_Include
	//	*ProjectExpression_Expression
	//	*ProjectExpression_Literal
	ExpressionType isProjectExpression_ExpressionType `protobuf_oneof:"expression_type"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProjectExpression) Reset() {
	*x = ProjectExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectExpression) ProtoMessage() {}

func (x *ProjectExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectExpression.ProtoReflect.Descriptor instead.
func (*ProjectExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{4}
}

func (x *ProjectExpression) GetExpressionType() isProjectExpression_ExpressionType {
	if x != nil {
		return x.ExpressionType
	}
	return nil
}

func (x *ProjectExpression) GetInclude() bool {
	if x != nil {
		if x, ok := x.ExpressionType.(*ProjectExpression_Include); ok {
			return x.Include
		}
	}
	return false
}

func (x *ProjectExpression) GetExpression() *AggregationExpression {
	if x != nil {
		if x, ok := x.ExpressionType.(*ProjectExpression_Expression); ok {
			return x.Expression
		}
	}
	return nil
}

func (x *ProjectExpression) GetLiteral() *Value {
	if x != nil {
		if x, ok := x.ExpressionType.(*ProjectExpression_Literal); ok {
			return x.Literal
		}
	}
	return nil
}

type isProjectExpression_ExpressionType interface {
	isProjectExpression_ExpressionType()
}

type ProjectExpression_Include struct {
	// Include (1) or exclude (0) the field.
	Include bool `protobuf:"varint,1,opt,name=include,proto3,oneof"`
}

type ProjectExpression_Expression struct {
	// A computed expression.
	Expression *AggregationExpression `protobuf:"bytes,2,opt,name=expression,proto3,oneof"`
}

type ProjectExpression_Literal struct {
	// Literal value.
	Literal *Value `protobuf:"bytes,3,opt,name=literal,proto3,oneof"`
}

func (*ProjectExpression_Include) isProjectExpression_ExpressionType() {}

func (*ProjectExpression_Expression) isProjectExpression_ExpressionType() {}

func (*ProjectExpression_Literal) isProjectExpression_ExpressionType() {}

// $group stage - Group and aggregate.
type GroupStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The _id expression for grouping.
	// Use null for a single group.
	Id *AggregationExpression `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Accumulator expressions for each output field.
	Accumulators  map[string]*Accumulator `protobuf:"bytes,2,rep,name=accumulators,proto3" json:"accumulators,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GroupStage) Reset() {
	*x = GroupStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GroupStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupStage) ProtoMessage() {}

func (x *GroupStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GroupStage.ProtoReflect.Descriptor instead.
func (*GroupStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{5}
}

func (x *GroupStage) GetId() *AggregationExpression {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *GroupStage) GetAccumulators() map[string]*Accumulator {
	if x != nil {
		return x.Accumulators
	}
	return nil
}

// An accumulator for group operations.
type Accumulator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The accumulator type.
	Type Accumulator_Type `protobuf:"varint,1,opt,name=type,proto3,enum=mongorpc.v1.Accumulator_Type" json:"type,omitempty"`
	// The expression to accumulate.
	Expression *AggregationExpression `protobuf:"bytes,2,opt,name=expression,proto3" json:"expression,omitempty"`
	// For N-accumulators, the value of N.
	N int32 `protobuf:"varint,3,opt,name=n,proto3" json:"n,omitempty"`
	// For top/bottom, the sort specification.
	Sort          []*SortOrder `protobuf:"bytes,4,rep,name=sort,proto3" json:"sort,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Accumulator) Reset() {
	*x = Accumulator{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Accumulator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Accumulator) ProtoMessage() {}

func (x *Accumulator) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Accumulator.ProtoReflect.Descriptor instead.
func (*Accumulator) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{6}
}

func (x *Accumulator) GetType() Accumulator_Type {
	if x != nil {
		return x.Type
	}
	return Accumulator_TYPE_UNSPECIFIED
}

func (x *Accumulator) GetExpression() *AggregationExpression {
	if x != nil {
		return x.Expression
	}
	return nil
}

func (x *Accumulator) GetN() int32 {
	if x != nil {
		return x.N
	}
	return 0
}

func (x *Accumulator) GetSort() []*SortOrder {
	if x != nil {
		return x.Sort
	}
	return nil
}

// An aggregation expression.
type AggregationExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ExpressionType:
	//
	//	*AggregationExpression_FieldRef
	//	*AggregationExpression_Literal
	//	*AggregationExpression_Variable
	//	*AggregationExpression_Operator
	//	*AggregationExpression_Conditional
	ExpressionType isAggregationExpression_ExpressionType `protobuf_oneof:"expression_type"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AggregationExpression) Reset() {
	*x = AggregationExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationExpression) ProtoMessage() {}

func (x *AggregationExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationExpression.ProtoReflect.Descriptor instead.
func (*AggregationExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{7}
}

func (x *AggregationExpression) GetExpressionType() isAggregationExpression_ExpressionType {
	if x != nil {
		return x.ExpressionType
	}
	return nil
}

func (x *AggregationExpression) GetFieldRef() string {
	if x != nil {
		if x, ok := x.ExpressionType.(*AggregationExpression_FieldRef); ok {
			return x.FieldRef
		}
	}
	return ""
}

func (x *AggregationExpression) GetLiteral() *Value {
	if x != nil {
		if x, ok := x.ExpressionType.(*AggregationExpression_Literal); ok {
			return x.Literal
		}
	}
	return nil
}

func (x *AggregationExpression) GetVariable() string {
	if x != nil {
		if x, ok := x.ExpressionType.(*AggregationExpression_Variable); ok {
			return x.Variable
		}
	}
	return ""
}

func (x *AggregationExpression) GetOperator() *OperatorExpression {
	if x != nil {
		if x, ok := x.ExpressionType.(*AggregationExpression_Operator); ok {
			return x.Operator
		}
	}
	return nil
}

func (x *AggregationExpression) GetConditional() *ConditionalExpression {
	if x != nil {
		if x, ok := x.ExpressionType.(*AggregationExpression_Conditional); ok {
			return x.Conditional
		}
	}
	return nil
}

type isAggregationExpression_ExpressionType interface {
	isAggregationExpression_ExpressionType()
}

type AggregationExpression_FieldRef struct {
	// A field reference (e.g., "$fieldName").
	FieldRef string `protobuf:"bytes,1,opt,name=field_ref,json=fieldRef,proto3,oneof"`
}

type AggregationExpression_Literal struct {
	// A literal value.
	Literal *Value `protobuf:"bytes,2,opt,name=literal,proto3,oneof"`
}

type AggregationExpression_Variable struct {
	// A system variable (e.g., "$$ROOT", "$$NOW").
	Variable string `protobuf:"bytes,3,opt,name=variable,proto3,oneof"`
}

type AggregationExpression_Operator struct {
	// An operator expression.
	Operator *OperatorExpression `protobuf:"bytes,4,opt,name=operator,proto3,oneof"`
}

type AggregationExpression_Conditional struct {
	// A conditional expression.
	Conditional *ConditionalExpression `protobuf:"bytes,5,opt,name=conditional,proto3,oneof"`
}

func (*AggregationExpression_FieldRef) isAggregationExpression_ExpressionType() {}

func (*AggregationExpression_Literal) isAggregationExpression_ExpressionType() {}

func (*AggregationExpression_Variable) isAggregationExpression_ExpressionType() {}

func (*AggregationExpression_Operator) isAggregationExpression_ExpressionType() {}

func (*AggregationExpression_Conditional) isAggregationExpression_ExpressionType() {}

// An operator expression.
type OperatorExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The operator name (e.g., "$add", "$concat").
	Op string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	// The arguments to the operator.
	Args          []*AggregationExpression `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperatorExpression) Reset() {
	*x = OperatorExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorExpression) ProtoMessage() {}

func (x *OperatorExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorExpression.ProtoReflect.Descriptor instead.
func (*OperatorExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{8}
}

func (x *OperatorExpression) GetOp() string {
	if x != nil {
		return x.Op
	}
	return ""
}

func (x *OperatorExpression) GetArgs() []*AggregationExpression {
	if x != nil {
		return x.Args
	}
	return nil
}

// A conditional expression ($cond, $ifNull, $switch).
type ConditionalExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ConditionalType:
	//
	//	*ConditionalExpression_Cond
	//	*ConditionalExpression_IfNull
	//	*ConditionalExpression_Switch
	ConditionalType isConditionalExpression_ConditionalType `protobuf_oneof:"conditional_type"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ConditionalExpression) Reset() {
	*x = ConditionalExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConditionalExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConditionalExpression) ProtoMessage() {}

func (x *ConditionalExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConditionalExpression.ProtoReflect.Descriptor instead.
func (*ConditionalExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{9}
}

func (x *ConditionalExpression) GetConditionalType() isConditionalExpression_ConditionalType {
	if x != nil {
		return x.ConditionalType
	}
	return nil
}

func (x *ConditionalExpression) GetCond() *CondExpression {
	if x != nil {
		if x, ok := x.ConditionalType.(*ConditionalExpression_Cond); ok {
			return x.Cond
		}
	}
	return nil
}

func (x *ConditionalExpression) GetIfNull() *IfNullExpression {
	if x != nil {
		if x, ok := x.ConditionalType.(*ConditionalExpression_IfNull); ok {
			return x.IfNull
		}
	}
	return nil
}

func (x *ConditionalExpression) GetSwitch() *SwitchExpression {
	if x != nil {
		if x, ok := x.ConditionalType.(*ConditionalExpression_Switch); ok {
			return x.Switch
		}
	}
	return nil
}

type isConditionalExpression_ConditionalType interface {
	isConditionalExpression_ConditionalType()
}

type ConditionalExpression_Cond struct {
	// $cond - if/then/else.
	Cond *CondExpression `protobuf:"bytes,1,opt,name=cond,proto3,oneof"`
}

type ConditionalExpression_IfNull struct {
	// $ifNull - null coalescing.
	IfNull *IfNullExpression `protobuf:"bytes,2,opt,name=if_null,json=ifNull,proto3,oneof"`
}

type ConditionalExpression_Switch struct {
	// $switch - multi-branch conditional.
	Switch *SwitchExpression `protobuf:"bytes,3,opt,name=switch,proto3,oneof"`
}

func (*ConditionalExpression_Cond) isConditionalExpression_ConditionalType() {}

func (*ConditionalExpression_IfNull) isConditionalExpression_ConditionalType() {}

func (*ConditionalExpression_Switch) isConditionalExpression_ConditionalType() {}

// $cond expression.
type CondExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The condition to evaluate.
	If *AggregationExpression `protobuf:"bytes,1,opt,name=if,proto3" json:"if,omitempty"`
	// Value if condition is true.
	Then *AggregationExpression `protobuf:"bytes,2,opt,name=then,proto3" json:"then,omitempty"`
	// Value if condition is false.
	Else          *AggregationExpression `protobuf:"bytes,3,opt,name=else,proto3" json:"else,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CondExpression) Reset() {
	*x = CondExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CondExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CondExpression) ProtoMessage() {}

func (x *CondExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CondExpression.ProtoReflect.Descriptor instead.
func (*CondExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{10}
}

func (x *CondExpression) GetIf() *AggregationExpression {
	if x != nil {
		return x.If
	}
	return nil
}

func (x *CondExpression) GetThen() *AggregationExpression {
	if x != nil {
		return x.Then
	}
	return nil
}

func (x *CondExpression) GetElse() *AggregationExpression {
	if x != nil {
		return x.Else
	}
	return nil
}

// $ifNull expression.
type IfNullExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Expression to check for null.
	Expression *AggregationExpression `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	// Replacement value if null.
	Replacement   *AggregationExpression `protobuf:"bytes,2,opt,name=replacement,proto3" json:"replacement,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IfNullExpression) Reset() {
	*x = IfNullExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IfNullExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IfNullExpression) ProtoMessage() {}

func (x *IfNullExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IfNullExpression.ProtoReflect.Descriptor instead.
func (*IfNullExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{11}
}

func (x *IfNullExpression) GetExpression() *AggregationExpression {
	if x != nil {
		return x.Expression
	}
	return nil
}

func (x *IfNullExpression) GetReplacement() *AggregationExpression {
	if x != nil {
		return x.Replacement
	}
	return nil
}

// $switch expression.
type SwitchExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Branch cases.
	Branches []*SwitchBranch `protobuf:"bytes,1,rep,name=branches,proto3" json:"branches,omitempty"`
	// Default value if no branch matches.
	Default       *AggregationExpression `protobuf:"bytes,2,opt,name=default,proto3" json:"default,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchExpression) Reset() {
	*x = SwitchExpression{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchExpression) ProtoMessage() {}

func (x *SwitchExpression) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchExpression.ProtoReflect.Descriptor instead.
func (*SwitchExpression) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{12}
}

func (x *SwitchExpression) GetBranches() []*SwitchBranch {
	if x != nil {
		return x.Branches
	}
	return nil
}

func (x *SwitchExpression) GetDefault() *AggregationExpression {
	if x != nil {
		return x.Default
	}
	return nil
}

// A branch in a $switch expression.
type SwitchBranch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The condition to check.
	Case *AggregationExpression `protobuf:"bytes,1,opt,name=case,proto3" json:"case,omitempty"`
	// The value if condition is true.
	Then          *AggregationExpression `protobuf:"bytes,2,opt,name=then,proto3" json:"then,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchBranch) Reset() {
	*x = SwitchBranch{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchBranch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchBranch) ProtoMessage() {}

func (x *SwitchBranch) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchBranch.ProtoReflect.Descriptor instead.
func (*SwitchBranch) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{13}
}

func (x *SwitchBranch) GetCase() *AggregationExpression {
	if x != nil {
		return x.Case
	}
	return nil
}

func (x *SwitchBranch) GetThen() *AggregationExpression {
	if x != nil {
		return x.Then
	}
	return nil
}

// $sort stage.
type SortStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sort specification.
	Sort          []*SortOrder `protobuf:"bytes,1,rep,name=sort,proto3" json:"sort,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SortStage) Reset() {
	*x = SortStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SortStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SortStage) ProtoMessage() {}

func (x *SortStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SortStage.ProtoReflect.Descriptor instead.
func (*SortStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{14}
}

func (x *SortStage) GetSort() []*SortOrder {
	if x != nil {
		return x.Sort
	}
	return nil
}

// $limit stage.
type LimitStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum number of documents.
	Limit         int64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LimitStage) Reset() {
	*x = LimitStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LimitStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LimitStage) ProtoMessage() {}

func (x *LimitStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LimitStage.ProtoReflect.Descriptor instead.
func (*LimitStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{15}
}

func (x *LimitStage) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

// $skip stage.
type SkipStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of documents to skip.
	Skip          int64 `protobuf:"varint,1,opt,name=skip,proto3" json:"skip,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SkipStage) Reset() {
	*x = SkipStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SkipStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SkipStage) ProtoMessage() {}

func (x *SkipStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SkipStage.ProtoReflect.Descriptor instead.
func (*SkipStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{16}
}

func (x *SkipStage) GetSkip() int64 {
	if x != nil {
		return x.Skip
	}
	return 0
}

// $unwind stage - Deconstruct an array field.
type UnwindStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The array field path (with $ prefix).
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Include the array index in output.
	IncludeArrayIndex string `protobuf:"bytes,2,opt,name=include_array_index,json=includeArrayIndex,proto3" json:"include_array_index,omitempty"`
	// Preserve documents with null/missing/empty arrays.
	PreserveNullAndEmptyArrays bool `protobuf:"varint,3,opt,name=preserve_null_and_empty_arrays,json=preserveNullAndEmptyArrays,proto3" json:"preserve_null_and_empty_arrays,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *UnwindStage) Reset() {
	*x = UnwindStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnwindStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnwindStage) ProtoMessage() {}

func (x *UnwindStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnwindStage.ProtoReflect.Descriptor instead.
func (*UnwindStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{17}
}

func (x *UnwindStage) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *UnwindStage) GetIncludeArrayIndex() string {
	if x != nil {
		return x.IncludeArrayIndex
	}
	return ""
}

func (x *UnwindStage) GetPreserveNullAndEmptyArrays() bool {
	if x != nil {
		return x.PreserveNullAndEmptyArrays
	}
	return false
}

// $lookup stage - Left outer join.
type LookupStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The collection to join with.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The local field to join on.
	LocalField string `protobuf:"bytes,2,opt,name=local_field,json=localField,proto3" json:"local_field,omitempty"`
	// The foreign field to join on.
	ForeignField string `protobuf:"bytes,3,opt,name=foreign_field,json=foreignField,proto3" json:"foreign_field,omitempty"`
	// The output array field name.
	As string `protobuf:"bytes,4,opt,name=as,proto3" json:"as,omitempty"`
	// For uncorrelated subqueries, the pipeline to run.
	Pipeline []*PipelineStage `protobuf:"bytes,5,rep,name=pipeline,proto3" json:"pipeline,omitempty"`
	// Variables to pass to the pipeline.
	Let           map[string]*AggregationExpression `protobuf:"bytes,6,rep,name=let,proto3" json:"let,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LookupStage) Reset() {
	*x = LookupStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LookupStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LookupStage) ProtoMessage() {}

func (x *LookupStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LookupStage.ProtoReflect.Descriptor instead.
func (*LookupStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{18}
}

func (x *LookupStage) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *LookupStage) GetLocalField() string {
	if x != nil {
		return x.LocalField
	}
	return ""
}

func (x *LookupStage) GetForeignField() string {
	if x != nil {
		return x.ForeignField
	}
	return ""
}

func (x *LookupStage) GetAs() string {
	if x != nil {
		return x.As
	}
	return ""
}

func (x *LookupStage) GetPipeline() []*PipelineStage {
	if x != nil {
		return x.Pipeline
	}
	return nil
}

func (x *LookupStage) GetLet() map[string]*AggregationExpression {
	if x != nil {
		return x.Let
	}
	return nil
}

// $addFields / $set stage.
type AddFieldsStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Fields to add.
	Fields        map[string]*AggregationExpression `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddFieldsStage) Reset() {
	*x = AddFieldsStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddFieldsStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddFieldsStage) ProtoMessage() {}

func (x *AddFieldsStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddFieldsStage.ProtoReflect.Descriptor instead.
func (*AddFieldsStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{19}
}

func (x *AddFieldsStage) GetFields() map[string]*AggregationExpression {
	if x != nil {
		return x.Fields
	}
	return nil
}

// $unset stage - Remove fields.
type UnsetStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Fields to remove.
	Fields        []string `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsetStage) Reset() {
	*x = UnsetStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsetStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsetStage) ProtoMessage() {}

func (x *UnsetStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsetStage.ProtoReflect.Descriptor instead.
func (*UnsetStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{20}
}

func (x *UnsetStage) GetFields() []string {
	if x != nil {
		return x.Fields
	}
	return nil
}

// $replaceRoot stage.
type ReplaceRootStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The new root document expression.
	NewRoot       *AggregationExpression `protobuf:"bytes,1,opt,name=new_root,json=newRoot,proto3" json:"new_root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplaceRootStage) Reset() {
	*x = ReplaceRootStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplaceRootStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceRootStage) ProtoMessage() {}

func (x *ReplaceRootStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceRootStage.ProtoReflect.Descriptor instead.
func (*ReplaceRootStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{21}
}

func (x *ReplaceRootStage) GetNewRoot() *AggregationExpression {
	if x != nil {
		return x.NewRoot
	}
	return nil
}

// $count stage.
type CountStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The output field name for the count.
	Field         string `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CountStage) Reset() {
	*x = CountStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CountStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CountStage) ProtoMessage() {}

func (x *CountStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CountStage.ProtoReflect.Descriptor instead.
func (*CountStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{22}
}

func (x *CountStage) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

// $facet stage - Run multiple pipelines.
type FacetStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Named pipelines to run in parallel.
	Facets        map[string]*SubPipeline `protobuf:"bytes,1,rep,name=facets,proto3" json:"facets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FacetStage) Reset() {
	*x = FacetStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FacetStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FacetStage) ProtoMessage() {}

func (x *FacetStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FacetStage.ProtoReflect.Descriptor instead.
func (*FacetStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{23}
}

func (x *FacetStage) GetFacets() map[string]*SubPipeline {
	if x != nil {
		return x.Facets
	}
	return nil
}

// A sub-pipeline for $facet.
type SubPipeline struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The pipeline stages.
	Stages        []*PipelineStage `protobuf:"bytes,1,rep,name=stages,proto3" json:"stages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubPipeline) Reset() {
	*x = SubPipeline{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubPipeline) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubPipeline) ProtoMessage() {}

func (x *SubPipeline) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubPipeline.ProtoReflect.Descriptor instead.
func (*SubPipeline) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{24}
}

func (x *SubPipeline) GetStages() []*PipelineStage {
	if x != nil {
		return x.Stages
	}
	return nil
}

// $bucket stage.
type BucketStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field or expression to bucket by.
	GroupBy *AggregationExpression `protobuf:"bytes,1,opt,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// The bucket boundaries.
	Boundaries []*Value `protobuf:"bytes,2,rep,name=boundaries,proto3" json:"boundaries,omitempty"`
	// Default bucket for values outside boundaries.
	Default *Value `protobuf:"bytes,3,opt,name=default,proto3" json:"default,omitempty"`
	// Output field accumulators.
	Output        map[string]*Accumulator `protobuf:"bytes,4,rep,name=output,proto3" json:"output,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketStage) Reset() {
	*x = BucketStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketStage) ProtoMessage() {}

func (x *BucketStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketStage.ProtoReflect.Descriptor instead.
func (*BucketStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{25}
}

func (x *BucketStage) GetGroupBy() *AggregationExpression {
	if x != nil {
		return x.GroupBy
	}
	return nil
}

func (x *BucketStage) GetBoundaries() []*Value {
	if x != nil {
		return x.Boundaries
	}
	return nil
}

func (x *BucketStage) GetDefault() *Value {
	if x != nil {
		return x.Default
	}
	return nil
}

func (x *BucketStage) GetOutput() map[string]*Accumulator {
	if x != nil {
		return x.Output
	}
	return nil
}

// $bucketAuto stage.
type BucketAutoStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The field or expression to bucket by.
	GroupBy *AggregationExpression `protobuf:"bytes,1,opt,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// The number of buckets.
	Buckets int32 `protobuf:"varint,2,opt,name=buckets,proto3" json:"buckets,omitempty"`
	// Output field accumulators.
	Output map[string]*Accumulator `protobuf:"bytes,3,rep,name=output,proto3" json:"output,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Preferred number series (R5, R10, R20, R40, R80, 1-2-5, POWERSOF2).
	Granularity   string `protobuf:"bytes,4,opt,name=granularity,proto3" json:"granularity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketAutoStage) Reset() {
	*x = BucketAutoStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketAutoStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketAutoStage) ProtoMessage() {}

func (x *BucketAutoStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketAutoStage.ProtoReflect.Descriptor instead.
func (*BucketAutoStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{26}
}

func (x *BucketAutoStage) GetGroupBy() *AggregationExpression {
	if x != nil {
		return x.GroupBy
	}
	return nil
}

func (x *BucketAutoStage) GetBuckets() int32 {
	if x != nil {
		return x.Buckets
	}
	return 0
}

func (x *BucketAutoStage) GetOutput() map[string]*Accumulator {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *BucketAutoStage) GetGranularity() string {
	if x != nil {
		return x.Granularity
	}
	return ""
}

// $sample stage.
type SampleStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of documents to sample.
	Size          int64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SampleStage) Reset() {
	*x = SampleStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SampleStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SampleStage) ProtoMessage() {}

func (x *SampleStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SampleStage.ProtoReflect.Descriptor instead.
func (*SampleStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{27}
}

func (x *SampleStage) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

// $out stage - Write to collection.
type OutStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The output database (optional, defaults to current).
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// The output collection.
	Collection    string `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutStage) Reset() {
	*x = OutStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutStage) ProtoMessage() {}

func (x *OutStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutStage.ProtoReflect.Descriptor instead.
func (*OutStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{28}
}

func (x *OutStage) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *OutStage) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

// $merge stage - Merge into collection.
type MergeStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The output database.
	IntoDatabase string `protobuf:"bytes,1,opt,name=into_database,json=intoDatabase,proto3" json:"into_database,omitempty"`
	// The output collection.
	IntoCollection string `protobuf:"bytes,2,opt,name=into_collection,json=intoCollection,proto3" json:"into_collection,omitempty"`
	// Fields to match existing documents.
	On []string `protobuf:"bytes,3,rep,name=on,proto3" json:"on,omitempty"`
	// Action when document matches.
	WhenMatched string `protobuf:"bytes,4,opt,name=when_matched,json=whenMatched,proto3" json:"when_matched,omitempty"`
	// Action when document doesn't match.
	WhenNotMatched string `protobuf:"bytes,5,opt,name=when_not_matched,json=whenNotMatched,proto3" json:"when_not_matched,omitempty"`
	// Pipeline to apply when matched.
	Let           []*PipelineStage `protobuf:"bytes,6,rep,name=let,proto3" json:"let,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergeStage) Reset() {
	*x = MergeStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergeStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergeStage) ProtoMessage() {}

func (x *MergeStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergeStage.ProtoReflect.Descriptor instead.
func (*MergeStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{29}
}

func (x *MergeStage) GetIntoDatabase() string {
	if x != nil {
		return x.IntoDatabase
	}
	return ""
}

func (x *MergeStage) GetIntoCollection() string {
	if x != nil {
		return x.IntoCollection
	}
	return ""
}

func (x *MergeStage) GetOn() []string {
	if x != nil {
		return x.On
	}
	return nil
}

func (x *MergeStage) GetWhenMatched() string {
	if x != nil {
		return x.WhenMatched
	}
	return ""
}

func (x *MergeStage) GetWhenNotMatched() string {
	if x != nil {
		return x.WhenNotMatched
	}
	return ""
}

func (x *MergeStage) GetLet() []*PipelineStage {
	if x != nil {
		return x.Let
	}
	return nil
}

// $geoNear stage.
type GeoNearStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The point to search near.
	Near *GeoPoint `protobuf:"bytes,1,opt,name=near,proto3" json:"near,omitempty"`
	// The output distance field.
	DistanceField string `protobuf:"bytes,2,opt,name=distance_field,json=distanceField,proto3" json:"distance_field,omitempty"`
	// Whether to use spherical geometry.
	Spherical bool `protobuf:"varint,3,opt,name=spherical,proto3" json:"spherical,omitempty"`
	// Maximum distance in meters.
	MaxDistance float64 `protobuf:"fixed64,4,opt,name=max_distance,json=maxDistance,proto3" json:"max_distance,omitempty"`
	// Minimum distance in meters.
	MinDistance float64 `protobuf:"fixed64,5,opt,name=min_distance,json=minDistance,proto3" json:"min_distance,omitempty"`
	// Additional filter.
	Query *Filter `protobuf:"bytes,6,opt,name=query,proto3" json:"query,omitempty"`
	// Distance multiplier.
	DistanceMultiplier float64 `protobuf:"fixed64,7,opt,name=distance_multiplier,json=distanceMultiplier,proto3" json:"distance_multiplier,omitempty"`
	// Include location field in output.
	IncludeLocs string `protobuf:"bytes,8,opt,name=include_locs,json=includeLocs,proto3" json:"include_locs,omitempty"`
	// The field with geospatial data.
	Key           string `protobuf:"bytes,9,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeoNearStage) Reset() {
	*x = GeoNearStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeoNearStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeoNearStage) ProtoMessage() {}

func (x *GeoNearStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeoNearStage.ProtoReflect.Descriptor instead.
func (*GeoNearStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{30}
}

func (x *GeoNearStage) GetNear() *GeoPoint {
	if x != nil {
		return x.Near
	}
	return nil
}

func (x *GeoNearStage) GetDistanceField() string {
	if x != nil {
		return x.DistanceField
	}
	return ""
}

func (x *GeoNearStage) GetSpherical() bool {
	if x != nil {
		return x.Spherical
	}
	return false
}

func (x *GeoNearStage) GetMaxDistance() float64 {
	if x != nil {
		return x.MaxDistance
	}
	return 0
}

func (x *GeoNearStage) GetMinDistance() float64 {
	if x != nil {
		return x.MinDistance
	}
	return 0
}

func (x *GeoNearStage) GetQuery() *Filter {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *GeoNearStage) GetDistanceMultiplier() float64 {
	if x != nil {
		return x.DistanceMultiplier
	}
	return 0
}

func (x *GeoNearStage) GetIncludeLocs() string {
	if x != nil {
		return x.IncludeLocs
	}
	return ""
}

func (x *GeoNearStage) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// $graphLookup stage - Recursive lookup.
type GraphLookupStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The collection to search.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// Starting value expression.
	StartWith *AggregationExpression `protobuf:"bytes,2,opt,name=start_with,json=startWith,proto3" json:"start_with,omitempty"`
	// Field to match in recursive search.
	ConnectFromField string `protobuf:"bytes,3,opt,name=connect_from_field,json=connectFromField,proto3" json:"connect_from_field,omitempty"`
	// Field to match in documents.
	ConnectToField string `protobuf:"bytes,4,opt,name=connect_to_field,json=connectToField,proto3" json:"connect_to_field,omitempty"`
	// Output array field name.
	As string `protobuf:"bytes,5,opt,name=as,proto3" json:"as,omitempty"`
	// Maximum recursion depth.
	MaxDepth int32 `protobuf:"varint,6,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	// Field to store depth level.
	DepthField string `protobuf:"bytes,7,opt,name=depth_field,json=depthField,proto3" json:"depth_field,omitempty"`
	// Additional filter for matches.
	RestrictSearchWithMatch *Filter `protobuf:"bytes,8,opt,name=restrict_search_with_match,json=restrictSearchWithMatch,proto3" json:"restrict_search_with_match,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *GraphLookupStage) Reset() {
	*x = GraphLookupStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GraphLookupStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphLookupStage) ProtoMessage() {}

func (x *GraphLookupStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphLookupStage.ProtoReflect.Descriptor instead.
func (*GraphLookupStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{31}
}

func (x *GraphLookupStage) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *GraphLookupStage) GetStartWith() *AggregationExpression {
	if x != nil {
		return x.StartWith
	}
	return nil
}

func (x *GraphLookupStage) GetConnectFromField() string {
	if x != nil {
		return x.ConnectFromField
	}
	return ""
}

func (x *GraphLookupStage) GetConnectToField() string {
	if x != nil {
		return x.ConnectToField
	}
	return ""
}

func (x *GraphLookupStage) GetAs() string {
	if x != nil {
		return x.As
	}
	return ""
}

func (x *GraphLookupStage) GetMaxDepth() int32 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *GraphLookupStage) GetDepthField() string {
	if x != nil {
		return x.DepthField
	}
	return ""
}

func (x *GraphLookupStage) GetRestrictSearchWithMatch() *Filter {
	if x != nil {
		return x.RestrictSearchWithMatch
	}
	return nil
}

// $unionWith stage.
type UnionWithStage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The collection to union with.
	Collection string `protobuf:"bytes,1,opt,name=collection,proto3" json:"collection,omitempty"`
	// Optional pipeline to apply to the collection.
	Pipeline      []*PipelineStage `protobuf:"bytes,2,rep,name=pipeline,proto3" json:"pipeline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnionWithStage) Reset() {
	*x = UnionWithStage{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnionWithStage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnionWithStage) ProtoMessage() {}

func (x *UnionWithStage) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnionWithStage.ProtoReflect.Descriptor instead.
func (*UnionWithStage) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{32}
}

func (x *UnionWithStage) GetCollection() string {
	if x != nil {
		return x.Collection
	}
	return ""
}

func (x *UnionWithStage) GetPipeline() []*PipelineStage {
	if x != nil {
		return x.Pipeline
	}
	return nil
}

// Aggregation options.
type AggregationOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Allow disk use for large result sets.
	AllowDiskUse bool `protobuf:"varint,1,opt,name=allow_disk_use,json=allowDiskUse,proto3" json:"allow_disk_use,omitempty"`
	// Maximum time in milliseconds.
	MaxTimeMs int64 `protobuf:"varint,2,opt,name=max_time_ms,json=maxTimeMs,proto3" json:"max_time_ms,omitempty"`
	// Batch size for cursor.
	BatchSize int32 `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// Read preference.
	ReadPreference *ReadPreference `protobuf:"bytes,4,opt,name=read_preference,json=readPreference,proto3" json:"read_preference,omitempty"`
	// Collation for string comparison.
	Collation *Collation `protobuf:"bytes,5,opt,name=collation,proto3" json:"collation,omitempty"`
	// Hint for index usage.
	Hint *IndexHint `protobuf:"bytes,6,opt,name=hint,proto3" json:"hint,omitempty"`
	// Comment for profiling.
	Comment string `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	// Whether to bypass document validation.
	BypassDocumentValidation bool `protobuf:"varint,8,opt,name=bypass_document_validation,json=bypassDocumentValidation,proto3" json:"bypass_document_validation,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *AggregationOptions) Reset() {
	*x = AggregationOptions{}
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregationOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregationOptions) ProtoMessage() {}

func (x *AggregationOptions) ProtoReflect() protoreflect.Message {
	mi := &file_mongorpc_v1_aggregation_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregationOptions.ProtoReflect.Descriptor instead.
func (*AggregationOptions) Descriptor() ([]byte, []int) {
	return file_mongorpc_v1_aggregation_proto_rawDescGZIP(), []int{33}
}

func (x *AggregationOptions) GetAllowDiskUse() bool {
	if x != nil {
		return x.AllowDiskUse
	}
	return false
}

func (x *AggregationOptions) GetMaxTimeMs() int64 {
	if x != nil {
		return x.MaxTimeMs
	}
	return 0
}

func (x *AggregationOptions) GetBatchSize() int32 {
	if x != nil {
		return x.BatchSize
	}
	return 0
}

func (x *AggregationOptions) GetReadPreference() *ReadPreference {
	if x != nil {
		return x.ReadPreference
	}
	return nil
}

func (x *AggregationOptions) GetCollation() *Collation {
	if x != nil {
		return x.Collation
	}
	return nil
}

func (x *AggregationOptions) GetHint() *IndexHint {
	if x != nil {
		return x.Hint
	}
	return nil
}

func (x *AggregationOptions) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *AggregationOptions) GetBypassDocumentValidation() bool {
	if x != nil {
		return x.BypassDocumentValidation
	}
	return false
}

var File_mongorpc_v1_aggregation_proto protoreflect.FileDescriptor

const file_mongorpc_v1_aggregation_proto_rawDesc = "" +
	"\n" +
	"\x1dmongorpc/v1/aggregation.proto\x12\vmongorpc.v1\x1a\x17mongorpc/v1/value.proto\x1a\x17mongorpc/v1/query.proto\x1a\x1amongorpc/v1/document.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xc0\x01\n" +
	"\x13AggregationPipeline\x12\x1a\n" +
	"\bdatabase\x18\x01 \x01(\tR\bdatabase\x12\x1e\n" +
	"\n" +
	"collection\x18\x02 \x01(\tR\n" +
	"collection\x122\n" +
	"\x06stages\x18\x03 \x03(\v2\x1a.mongorpc.v1.PipelineStageR\x06stages\x129\n" +
	"\aoptions\x18\x04 \x01(\v2\x1f.mongorpc.v1.AggregationOptionsR\aoptions\"\xdb\t\n" +
	"\rPipelineStage\x12/\n" +
	"\x05match\x18\x01 \x01(\v2\x17.mongorpc.v1.MatchStageH\x00R\x05match\x125\n" +
	"\aproject\x18\x02 \x01(\v2\x19.mongorpc.v1.ProjectStageH\x00R\aproject\x12/\n" +
	"\x05group\x18\x03 \x01(\v2\x17.mongorpc.v1.GroupStageH\x00R\x05group\x12,\n" +
	"\x04sort\x18\x04 \x01(\v2\x16.mongorpc.v1.SortStageH\x00R\x04sort\x12/\n" +
	"\x05limit\x18\x05 \x01(\v2\x17.mongorpc.v1.LimitStageH\x00R\x05limit\x12,\n" +
	"\x04skip\x18\x06 \x01(\v2\x16.mongorpc.v1.SkipStageH\x00R\x04skip\x122\n" +
	"\x06unwind\x18\a \x01(\v2\x18.mongorpc.v1.UnwindStageH\x00R\x06unwind\x122\n" +
	"\x06lookup\x18\b \x01(\v2\x18.mongorpc.v1.LookupStageH\x00R\x06lookup\x12<\n" +
	"\n" +
	"add_fields\x18\t \x01(\v2\x1b.mongorpc.v1.AddFieldsStageH\x00R\taddFields\x12/\n" +
	"\x03set\x18\n" +
	" \x01(\v2\x1b.mongorpc.v1.AddFieldsStageH\x00R\x03set\x12/\n" +
	"\x05unset\x18\v \x01(\v2\x17.mongorpc.v1.UnsetStageH\x00R\x05unset\x12B\n" +
	"\freplace_root\x18\f \x01(\v2\x1d.mongorpc.v1.ReplaceRootStageH\x00R\vreplaceRoot\x12/\n" +
	"\x05count\x18\r \x01(\v2\x17.mongorpc.v1.CountStageH\x00R\x05count\x12/\n" +
	"\x05facet\x18\x0e \x01(\v2\x17.mongorpc.v1.FacetStageH\x00R\x05facet\x122\n" +
	"\x06bucket\x18\x0f \x01(\v2\x18.mongorpc.v1.BucketStageH\x00R\x06bucket\x12?\n" +
	"\vbucket_auto\x18\x10 \x01(\v2\x1c.mongorpc.v1.BucketAutoStageH\x00R\n" +
	"bucketAuto\x122\n" +
	"\x06sample\x18\x11 \x01(\v2\x18.mongorpc.v1.SampleStageH\x00R\x06sample\x12)\n" +
	"\x03out\x18\x12 \x01(\v2\x15.mongorpc.v1.OutStageH\x00R\x03out\x12/\n" +
	"\x05merge\x18\x13 \x01(\v2\x17.mongorpc.v1.MergeStageH\x00R\x05merge\x126\n" +
	"\bgeo_near\x18\x14 \x01(\v2\x19.mongorpc.v1.GeoNearStageH\x00R\ageoNear\x12B\n" +
	"\fgraph_lookup\x18\x15 \x01(\v2\x1d.mongorpc.v1.GraphLookupStageH\x00R\vgraphLookup\x12<\n" +
	"\n" +
	"union_with\x18\x16 \x01(\v2\x1b.mongorpc.v1.UnionWithStageH\x00R\tunionWith\x12)\n" +
	"\x03raw\x18c \x01(\v2\x15.mongorpc.v1.MapValueH\x00R\x03rawB\f\n" +
	"\n" +
	"stage_type\"9\n" +
	"\n" +
	"MatchStage\x12+\n" +
	"\x06filter\x18\x01 \x01(\v2\x13.mongorpc.v1.FilterR\x06filter\"\xa8\x01\n" +
	"\fProjectStage\x12=\n" +
	"\x06fields\x18\x01 \x03(\v2%.mongorpc.v1.ProjectStage.FieldsEntryR\x06fields\x1aY\n" +
	"\vFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x124\n" +
	"\x05value\x18\x02 \x01(\v2\x1e.mongorpc.v1.ProjectExpressionR\x05value:\x028\x01\"\xb8\x01\n" +
	"\x11ProjectExpression\x12\x1a\n" +
	"\ainclude\x18\x01 \x01(\bH\x00R\ainclude\x12D\n" +
	"\n" +
	"expression\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionH\x00R\n" +
	"expression\x12.\n" +
	"\aliteral\x18\x03 \x01(\v2\x12.mongorpc.v1.ValueH\x00R\aliteralB\x11\n" +
	"\x0fexpression_type\"\xea\x01\n" +
	"\n" +
	"GroupStage\x122\n" +
	"\x02id\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x02id\x12M\n" +
	"\faccumulators\x18\x02 \x03(\v2).mongorpc.v1.GroupStage.AccumulatorsEntryR\faccumulators\x1aY\n" +
	"\x11AccumulatorsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.mongorpc.v1.AccumulatorR\x05value:\x028\x01\"\xb9\x03\n" +
	"\vAccumulator\x121\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1d.mongorpc.v1.Accumulator.TypeR\x04type\x12B\n" +
	"\n" +
	"expression\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\n" +
	"expression\x12\f\n" +
	"\x01n\x18\x03 \x01(\x05R\x01n\x12*\n" +
	"\x04sort\x18\x04 \x03(\v2\x16.mongorpc.v1.SortOrderR\x04sort\"\xf8\x01\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03SUM\x10\x01\x12\a\n" +
	"\x03AVG\x10\x02\x12\t\n" +
	"\x05FIRST\x10\x03\x12\b\n" +
	"\x04LAST\x10\x04\x12\a\n" +
	"\x03MAX\x10\x05\x12\a\n" +
	"\x03MIN\x10\x06\x12\b\n" +
	"\x04PUSH\x10\a\x12\x0e\n" +
	"\n" +
	"ADD_TO_SET\x10\b\x12\t\n" +
	"\x05COUNT\x10\t\x12\x0f\n" +
	"\vSTD_DEV_POP\x10\n" +
	"\x12\x10\n" +
	"\fSTD_DEV_SAMP\x10\v\x12\x11\n" +
	"\rMERGE_OBJECTS\x10\f\x12\t\n" +
	"\x05TOP_N\x10\r\x12\f\n" +
	"\bBOTTOM_N\x10\x0e\x12\v\n" +
	"\aFIRST_N\x10\x0f\x12\n" +
	"\n" +
	"\x06LAST_N\x10\x10\x12\t\n" +
	"\x05MAX_N\x10\x11\x12\t\n" +
	"\x05MIN_N\x10\x12\"\x9e\x02\n" +
	"\x15AggregationExpression\x12\x1d\n" +
	"\tfield_ref\x18\x01 \x01(\tH\x00R\bfieldRef\x12.\n" +
	"\aliteral\x18\x02 \x01(\v2\x12.mongorpc.v1.ValueH\x00R\aliteral\x12\x1c\n" +
	"\bvariable\x18\x03 \x01(\tH\x00R\bvariable\x12=\n" +
	"\boperator\x18\x04 \x01(\v2\x1f.mongorpc.v1.OperatorExpressionH\x00R\boperator\x12F\n" +
	"\vconditional\x18\x05 \x01(\v2\".mongorpc.v1.ConditionalExpressionH\x00R\vconditionalB\x11\n" +
	"\x0fexpression_type\"\\\n" +
	"\x12OperatorExpression\x12\x0e\n" +
	"\x02op\x18\x01 \x01(\tR\x02op\x126\n" +
	"\x04args\x18\x02 \x03(\v2\".mongorpc.v1.AggregationExpressionR\x04args\"\xd1\x01\n" +
	"\x15ConditionalExpression\x121\n" +
	"\x04cond\x18\x01 \x01(\v2\x1b.mongorpc.v1.CondExpressionH\x00R\x04cond\x128\n" +
	"\aif_null\x18\x02 \x01(\v2\x1d.mongorpc.v1.IfNullExpressionH\x00R\x06ifNull\x127\n" +
	"\x06switch\x18\x03 \x01(\v2\x1d.mongorpc.v1.SwitchExpressionH\x00R\x06switchB\x12\n" +
	"\x10conditional_type\"\xb4\x01\n" +
	"\x0eCondExpression\x122\n" +
	"\x02if\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x02if\x126\n" +
	"\x04then\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x04then\x126\n" +
	"\x04else\x18\x03 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x04else\"\x9c\x01\n" +
	"\x10IfNullExpression\x12B\n" +
	"\n" +
	"expression\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\n" +
	"expression\x12D\n" +
	"\vreplacement\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\vreplacement\"\x87\x01\n" +
	"\x10SwitchExpression\x125\n" +
	"\bbranches\x18\x01 \x03(\v2\x19.mongorpc.v1.SwitchBranchR\bbranches\x12<\n" +
	"\adefault\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\adefault\"~\n" +
	"\fSwitchBranch\x126\n" +
	"\x04case\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x04case\x126\n" +
	"\x04then\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x04then\"7\n" +
	"\tSortStage\x12*\n" +
	"\x04sort\x18\x01 \x03(\v2\x16.mongorpc.v1.SortOrderR\x04sort\"\"\n" +
	"\n" +
	"LimitStage\x12\x14\n" +
	"\x05limit\x18\x01 \x01(\x03R\x05limit\"\x1f\n" +
	"\tSkipStage\x12\x12\n" +
	"\x04skip\x18\x01 \x01(\x03R\x04skip\"\x95\x01\n" +
	"\vUnwindStage\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12.\n" +
	"\x13include_array_index\x18\x02 \x01(\tR\x11includeArrayIndex\x12B\n" +
	"\x1epreserve_null_and_empty_arrays\x18\x03 \x01(\bR\x1apreserveNullAndEmptyArrays\"\xc0\x02\n" +
	"\vLookupStage\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12\x1f\n" +
	"\vlocal_field\x18\x02 \x01(\tR\n" +
	"localField\x12#\n" +
	"\rforeign_field\x18\x03 \x01(\tR\fforeignField\x12\x0e\n" +
	"\x02as\x18\x04 \x01(\tR\x02as\x126\n" +
	"\bpipeline\x18\x05 \x03(\v2\x1a.mongorpc.v1.PipelineStageR\bpipeline\x123\n" +
	"\x03let\x18\x06 \x03(\v2!.mongorpc.v1.LookupStage.LetEntryR\x03let\x1aZ\n" +
	"\bLetEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x128\n" +
	"\x05value\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x05value:\x028\x01\"\xb0\x01\n" +
	"\x0eAddFieldsStage\x12?\n" +
	"\x06fields\x18\x01 \x03(\v2'.mongorpc.v1.AddFieldsStage.FieldsEntryR\x06fields\x1a]\n" +
	"\vFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x128\n" +
	"\x05value\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\x05value:\x028\x01\"$\n" +
	"\n" +
	"UnsetStage\x12\x16\n" +
	"\x06fields\x18\x01 \x03(\tR\x06fields\"Q\n" +
	"\x10ReplaceRootStage\x12=\n" +
	"\bnew_root\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\anewRoot\"\"\n" +
	"\n" +
	"CountStage\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\"\x9e\x01\n" +
	"\n" +
	"FacetStage\x12;\n" +
	"\x06facets\x18\x01 \x03(\v2#.mongorpc.v1.FacetStage.FacetsEntryR\x06facets\x1aS\n" +
	"\vFacetsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.mongorpc.v1.SubPipelineR\x05value:\x028\x01\"A\n" +
	"\vSubPipeline\x122\n" +
	"\x06stages\x18\x01 \x03(\v2\x1a.mongorpc.v1.PipelineStageR\x06stages\"\xc1\x02\n" +
	"\vBucketStage\x12=\n" +
	"\bgroup_by\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\agroupBy\x122\n" +
	"\n" +
	"boundaries\x18\x02 \x03(\v2\x12.mongorpc.v1.ValueR\n" +
	"boundaries\x12,\n" +
	"\adefault\x18\x03 \x01(\v2\x12.mongorpc.v1.ValueR\adefault\x12<\n" +
	"\x06output\x18\x04 \x03(\v2$.mongorpc.v1.BucketStage.OutputEntryR\x06output\x1aS\n" +
	"\vOutputEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.mongorpc.v1.AccumulatorR\x05value:\x028\x01\"\xa3\x02\n" +
	"\x0fBucketAutoStage\x12=\n" +
	"\bgroup_by\x18\x01 \x01(\v2\".mongorpc.v1.AggregationExpressionR\agroupBy\x12\x18\n" +
	"\abuckets\x18\x02 \x01(\x05R\abuckets\x12@\n" +
	"\x06output\x18\x03 \x03(\v2(.mongorpc.v1.BucketAutoStage.OutputEntryR\x06output\x12 \n" +
	"\vgranularity\x18\x04 \x01(\tR\vgranularity\x1aS\n" +
	"\vOutputEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.mongorpc.v1.AccumulatorR\x05value:\x028\x01\"!\n" +
	"\vSampleStage\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x03R\x04size\"F\n" +
	"\bOutStage\x12\x1a\n" +
	"\bdatabase\x18\x01 \x01(\tR\bdatabase\x12\x1e\n" +
	"\n" +
	"collection\x18\x02 \x01(\tR\n" +
	"collection\"\xe5\x01\n" +
	"\n" +
	"MergeStage\x12#\n" +
	"\rinto_database\x18\x01 \x01(\tR\fintoDatabase\x12'\n" +
	"\x0finto_collection\x18\x02 \x01(\tR\x0eintoCollection\x12\x0e\n" +
	"\x02on\x18\x03 \x03(\tR\x02on\x12!\n" +
	"\fwhen_matched\x18\x04 \x01(\tR\vwhenMatched\x12(\n" +
	"\x10when_not_matched\x18\x05 \x01(\tR\x0ewhenNotMatched\x12,\n" +
	"\x03let\x18\x06 \x03(\v2\x1a.mongorpc.v1.PipelineStageR\x03let\"\xd5\x02\n" +
	"\fGeoNearStage\x12)\n" +
	"\x04near\x18\x01 \x01(\v2\x15.mongorpc.v1.GeoPointR\x04near\x12%\n" +
	"\x0edistance_field\x18\x02 \x01(\tR\rdistanceField\x12\x1c\n" +
	"\tspherical\x18\x03 \x01(\bR\tspherical\x12!\n" +
	"\fmax_distance\x18\x04 \x01(\x01R\vmaxDistance\x12!\n" +
	"\fmin_distance\x18\x05 \x01(\x01R\vminDistance\x12)\n" +
	"\x05query\x18\x06 \x01(\v2\x13.mongorpc.v1.FilterR\x05query\x12/\n" +
	"\x13distance_multiplier\x18\a \x01(\x01R\x12distanceMultiplier\x12!\n" +
	"\finclude_locs\x18\b \x01(\tR\vincludeLocs\x12\x10\n" +
	"\x03key\x18\t \x01(\tR\x03key\"\xe1\x02\n" +
	"\x10GraphLookupStage\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12A\n" +
	"\n" +
	"start_with\x18\x02 \x01(\v2\".mongorpc.v1.AggregationExpressionR\tstartWith\x12,\n" +
	"\x12connect_from_field\x18\x03 \x01(\tR\x10connectFromField\x12(\n" +
	"\x10connect_to_field\x18\x04 \x01(\tR\x0econnectToField\x12\x0e\n" +
	"\x02as\x18\x05 \x01(\tR\x02as\x12\x1b\n" +
	"\tmax_depth\x18\x06 \x01(\x05R\bmaxDepth\x12\x1f\n" +
	"\vdepth_field\x18\a \x01(\tR\n" +
	"depthField\x12P\n" +
	"\x1arestrict_search_with_match\x18\b \x01(\v2\x13.mongorpc.v1.FilterR\x17restrictSearchWithMatch\"h\n" +
	"\x0eUnionWithStage\x12\x1e\n" +
	"\n" +
	"collection\x18\x01 \x01(\tR\n" +
	"collection\x126\n" +
	"\bpipeline\x18\x02 \x03(\v2\x1a.mongorpc.v1.PipelineStageR\bpipeline\"\xf9\x02\n" +
	"\x12AggregationOptions\x12$\n" +
	"\x0eallow_disk_use\x18\x01 \x01(\bR\fallowDiskUse\x12\x1e\n" +
	"\vmax_time_ms\x18\x02 \x01(\x03R\tmaxTimeMs\x12\x1d\n" +
	"\n" +
	"batch_size\x18\x03 \x01(\x05R\tbatchSize\x12D\n" +
	"\x0fread_preference\x18\x04 \x01(\v2\x1b.mongorpc.v1.ReadPreferenceR\x0ereadPreference\x124\n" +
	"\tcollation\x18\x05 \x01(\v2\x16.mongorpc.v1.CollationR\tcollation\x12*\n" +
	"\x04hint\x18\x06 \x01(\v2\x16.mongorpc.v1.IndexHintR\x04hint\x12\x18\n" +
	"\acomment\x18\a \x01(\tR\acomment\x12<\n" +
	"\x1abypass_document_validation\x18\b \x01(\bR\x18bypassDocumentValidationB\xa9\x01\n" +
	"\x0fcom.mongorpc.v1B\x10AggregationProtoP\x01Z7github.com/mongorpc/mongorpc/gen/mongorpc/v1;mongorpcv1\xa2\x02\x03MXX\xaa\x02\vMongorpc.V1\xca\x02\vMongorpc\\V1\xe2\x02\x17Mongorpc\\V1\\GPBMetadata\xea\x02\fMongorpc::V1b\x06proto3"

var (
	file_mongorpc_v1_aggregation_proto_rawDescOnce sync.Once
	file_mongorpc_v1_aggregation_proto_rawDescData []byte
)

func file_mongorpc_v1_aggregation_proto_rawDescGZIP() []byte {
	file_mongorpc_v1_aggregation_proto_rawDescOnce.Do(func() {
		file_mongorpc_v1_aggregation_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_mongorpc_v1_aggregation_proto_rawDesc), len(file_mongorpc_v1_aggregation_proto_rawDesc)))
	})
	return file_mongorpc_v1_aggregation_proto_rawDescData
}

var file_mongorpc_v1_aggregation_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_mongorpc_v1_aggregation_proto_msgTypes = make([]protoimpl.MessageInfo, 41)
var file_mongorpc_v1_aggregation_proto_goTypes = []any{
	(Accumulator_Type)(0),         // 0: mongorpc.v1.Accumulator.Type
	(*AggregationPipeline)(nil),   // 1: mongorpc.v1.AggregationPipeline
	(*PipelineStage)(nil),         // 2: mongorpc.v1.PipelineStage
	(*MatchStage)(nil),            // 3: mongorpc.v1.MatchStage
	(*ProjectStage)(nil),          // 4: mongorpc.v1.ProjectStage
	(*ProjectExpression)(nil),     // 5: mongorpc.v1.ProjectExpression
	(*GroupStage)(nil),            // 6: mongorpc.v1.GroupStage
	(*Accumulator)(nil),           // 7: mongorpc.v1.Accumulator
	(*AggregationExpression)(nil), // 8: mongorpc.v1.AggregationExpression
	(*OperatorExpression)(nil),    // 9: mongorpc.v1.OperatorExpression
	(*ConditionalExpression)(nil), // 10: mongorpc.v1.ConditionalExpression
	(*CondExpression)(nil),        // 11: mongorpc.v1.CondExpression
	(*IfNullExpression)(nil),      // 12: mongorpc.v1.IfNullExpression
	(*SwitchExpression)(nil),      // 13: mongorpc.v1.SwitchExpression
	(*SwitchBranch)(nil),          // 14: mongorpc.v1.SwitchBranch
	(*SortStage)(nil),             // 15: mongorpc.v1.SortStage
	(*LimitStage)(nil),            // 16: mongorpc.v1.LimitStage
	(*SkipStage)(nil),             // 17: mongorpc.v1.SkipStage
	(*UnwindStage)(nil),           // 18: mongorpc.v1.UnwindStage
	(*LookupStage)(nil),           // 19: mongorpc.v1.LookupStage
	(*AddFieldsStage)(nil),        // 20: mongorpc.v1.AddFieldsStage
	(*UnsetStage)(nil),            // 21: mongorpc.v1.UnsetStage
	(*ReplaceRootStage)(nil),      // 22: mongorpc.v1.ReplaceRootStage
	(*CountStage)(nil),            // 23: mongorpc.v1.CountStage
	(*FacetStage)(nil),            // 24: mongorpc.v1.FacetStage
	(*SubPipeline)(nil),           // 25: mongorpc.v1.SubPipeline
	(*BucketStage)(nil),           // 26: mongorpc.v1.BucketStage
	(*BucketAutoStage)(nil),       // 27: mongorpc.v1.BucketAutoStage
	(*SampleStage)(nil),           // 28: mongorpc.v1.SampleStage
	(*OutStage)(nil),              // 29: mongorpc.v1.OutStage
	(*MergeStage)(nil),            // 30: mongorpc.v1.MergeStage
	(*GeoNearStage)(nil),          // 31: mongorpc.v1.GeoNearStage
	(*GraphLookupStage)(nil),      // 32: mongorpc.v1.GraphLookupStage
	(*UnionWithStage)(nil),        // 33: mongorpc.v1.UnionWithStage
	(*AggregationOptions)(nil),    // 34: mongorpc.v1.AggregationOptions
	nil,                           // 35: mongorpc.v1.ProjectStage.FieldsEntry
	nil,                           // 36: mongorpc.v1.GroupStage.AccumulatorsEntry
	nil,                           // 37: mongorpc.v1.LookupStage.LetEntry
	nil,                           // 38: mongorpc.v1.AddFieldsStage.FieldsEntry
	nil,                           // 39: mongorpc.v1.FacetStage.FacetsEntry
	nil,                           // 40: mongorpc.v1.BucketStage.OutputEntry
	nil,                           // 41: mongorpc.v1.BucketAutoStage.OutputEntry
	(*MapValue)(nil),              // 42: mongorpc.v1.MapValue
	(*Filter)(nil),                // 43: mongorpc.v1.Filter
	(*Value)(nil),                 // 44: mongorpc.v1.Value
	(*SortOrder)(nil),             // 45: mongorpc.v1.SortOrder
	(*GeoPoint)(nil),              // 46: mongorpc.v1.GeoPoint
	(*ReadPreference)(nil),        // 47: mongorpc.v1.ReadPreference
	(*Collation)(nil),             // 48: mongorpc.v1.Collation
	(*IndexHint)(nil),             // 49: mongorpc.v1.IndexHint
}
var file_mongorpc_v1_aggregation_proto_depIdxs = []int32{
	2,  // 0: mongorpc.v1.AggregationPipeline.stages:type_name -> mongorpc.v1.PipelineStage
	34, // 1: mongorpc.v1.AggregationPipeline.options:type_name -> mongorpc.v1.AggregationOptions
	3,  // 2: mongorpc.v1.PipelineStage.match:type_name -> mongorpc.v1.MatchStage
	4,  // 3: mongorpc.v1.PipelineStage.project:type_name -> mongorpc.v1.ProjectStage
	6,  // 4: mongorpc.v1.PipelineStage.group:type_name -> mongorpc.v1.GroupStage
	15, // 5: mongorpc.v1.PipelineStage.sort:type_name -> mongorpc.v1.SortStage
	16, // 6: mongorpc.v1.PipelineStage.limit:type_name -> mongorpc.v1.LimitStage
	17, // 7: mongorpc.v1.PipelineStage.skip:type_name -> mongorpc.v1.SkipStage
	18, // 8: mongorpc.v1.PipelineStage.unwind:type_name -> mongorpc.v1.UnwindStage
	19, // 9: mongorpc.v1.PipelineStage.lookup:type_name -> mongorpc.v1.LookupStage
	20, // 10: mongorpc.v1.PipelineStage.add_fields:type_name -> mongorpc.v1.AddFieldsStage
	20, // 11: mongorpc.v1.PipelineStage.set:type_name -> mongorpc.v1.AddFieldsStage
	21, // 12: mongorpc.v1.PipelineStage.unset:type_name -> mongorpc.v1.UnsetStage
	22, // 13: mongorpc.v1.PipelineStage.replace_root:type_name -> mongorpc.v1.ReplaceRootStage
	23, // 14: mongorpc.v1.PipelineStage.count:type_name -> mongorpc.v1.CountStage
	24, // 15: mongorpc.v1.PipelineStage.facet:type_name -> mongorpc.v1.FacetStage
	26, // 16: mongorpc.v1.PipelineStage.bucket:type_name -> mongorpc.v1.BucketStage
	27, // 17: mongorpc.v1.PipelineStage.bucket_auto:type_name -> mongorpc.v1.BucketAutoStage
	28, // 18: mongorpc.v1.PipelineStage.sample:type_name -> mongorpc.v1.SampleStage
	29, // 19: mongorpc.v1.PipelineStage.out:type_name -> mongorpc.v1.OutStage
	30, // 20: mongorpc.v1.PipelineStage.merge:type_name -> mongorpc.v1.MergeStage
	31, // 21: mongorpc.v1.PipelineStage.geo_near:type_name -> mongorpc.v1.GeoNearStage
	32, // 22: mongorpc.v1.PipelineStage.graph_lookup:type_name -> mongorpc.v1.GraphLookupStage
	33, // 23: mongorpc.v1.PipelineStage.union_with:type_name -> mongorpc.v1.UnionWithStage
	42, // 24: mongorpc.v1.PipelineStage.raw:type_name -> mongorpc.v1.MapValue
	43, // 25: mongorpc.v1.MatchStage.filter:type_name -> mongorpc.v1.Filter
	35, // 26: mongorpc.v1.ProjectStage.fields:type_name -> mongorpc.v1.ProjectStage.FieldsEntry
	8,  // 27: mongorpc.v1.ProjectExpression.expression:type_name -> mongorpc.v1.AggregationExpression
	44, // 28: mongorpc.v1.ProjectExpression.literal:type_name -> mongorpc.v1.Value
	8,  // 29: mongorpc.v1.GroupStage.id:type_name -> mongorpc.v1.AggregationExpression
	36, // 30: mongorpc.v1.GroupStage.accumulators:type_name -> mongorpc.v1.GroupStage.AccumulatorsEntry
	0,  // 31: mongorpc.v1.Accumulator.type:type_name -> mongorpc.v1.Accumulator.Type
	8,  // 32: mongorpc.v1.Accumulator.expression:type_name -> mongorpc.v1.AggregationExpression
	45, // 33: mongorpc.v1.Accumulator.sort:type_name -> mongorpc.v1.SortOrder
	44, // 34: mongorpc.v1.AggregationExpression.literal:type_name -> mongorpc.v1.Value
	9,  // 35: mongorpc.v1.AggregationExpression.operator:type_name -> mongorpc.v1.OperatorExpression
	10, // 36: mongorpc.v1.AggregationExpression.conditional:type_name -> mongorpc.v1.ConditionalExpression
	8,  // 37: mongorpc.v1.OperatorExpression.args:type_name -> mongorpc.v1.AggregationExpression
	11, // 38: mongorpc.v1.ConditionalExpression.cond:type_name -> mongorpc.v1.CondExpression
	12, // 39: mongorpc.v1.ConditionalExpression.if_null:type_name -> mongorpc.v1.IfNullExpression
	13, // 40: mongorpc.v1.ConditionalExpression.switch:type_name -> mongorpc.v1.SwitchExpression
	8,  // 41: mongorpc.v1.CondExpression.if:type_name -> mongorpc.v1.AggregationExpression
	8,  // 42: mongorpc.v1.CondExpression.then:type_name -> mongorpc.v1.AggregationExpression
	8,  // 43: mongorpc.v1.CondExpression.else:type_name -> mongorpc.v1.AggregationExpression
	8,  // 44: mongorpc.v1.IfNullExpression.expression:type_name -> mongorpc.v1.AggregationExpression
	8,  // 45: mongorpc.v1.IfNullExpression.replacement:type_name -> mongorpc.v1.AggregationExpression
	14, // 46: mongorpc.v1.SwitchExpression.branches:type_name -> mongorpc.v1.SwitchBranch
	8,  // 47: mongorpc.v1.SwitchExpression.default:type_name -> mongorpc.v1.AggregationExpression
	8,  // 48: mongorpc.v1.SwitchBranch.case:type_name -> mongorpc.v1.AggregationExpression
	8,  // 49: mongorpc.v1.SwitchBranch.then:type_name -> mongorpc.v1.AggregationExpression
	45, // 50: mongorpc.v1.SortStage.sort:type_name -> mongorpc.v1.SortOrder
	2,  // 51: mongorpc.v1.LookupStage.pipeline:type_name -> mongorpc.v1.PipelineStage
	37, // 52: mongorpc.v1.LookupStage.let:type_name -> mongorpc.v1.LookupStage.LetEntry
	38, // 53: mongorpc.v1.AddFieldsStage.fields:type_name -> mongorpc.v1.AddFieldsStage.FieldsEntry
	8,  // 54: mongorpc.v1.ReplaceRootStage.new_root:type_name -> mongorpc.v1.AggregationExpression
	39, // 55: mongorpc.v1.FacetStage.facets:type_name -> mongorpc.v1.FacetStage.FacetsEntry
	2,  // 56: mongorpc.v1.SubPipeline.stages:type_name -> mongorpc.v1.PipelineStage
	8,  // 57: mongorpc.v1.BucketStage.group_by:type_name -> mongorpc.v1.AggregationExpression
	44, // 58: mongorpc.v1.BucketStage.boundaries:type_name -> mongorpc.v1.Value
	44, // 59: mongorpc.v1.BucketStage.default:type_name -> mongorpc.v1.Value
	40, // 60: mongorpc.v1.BucketStage.output:type_name -> mongorpc.v1.BucketStage.OutputEntry
	8,  // 61: mongorpc.v1.BucketAutoStage.group_by:type_name -> mongorpc.v1.AggregationExpression
	41, // 62: mongorpc.v1.BucketAutoStage.output:type_name -> mongorpc.v1.BucketAutoStage.OutputEntry
	2,  // 63: mongorpc.v1.MergeStage.let:type_name -> mongorpc.v1.PipelineStage
	46, // 64: mongorpc.v1.GeoNearStage.near:type_name -> mongorpc.v1.GeoPoint
	43, // 65: mongorpc.v1.GeoNearStage.query:type_name -> mongorpc.v1.Filter
	8,  // 66: mongorpc.v1.GraphLookupStage.start_with:type_name -> mongorpc.v1.AggregationExpression
	43, // 67: mongorpc.v1.GraphLookupStage.restrict_search_with_match:type_name -> mongorpc.v1.Filter
	2,  // 68: mongorpc.v1.UnionWithStage.pipeline:type_name -> mongorpc.v1.PipelineStage
	47, // 69: mongorpc.v1.AggregationOptions.read_preference:type_name -> mongorpc.v1.ReadPreference
	48, // 70: mongorpc.v1.AggregationOptions.collation:type_name -> mongorpc.v1.Collation
	49, // 71: mongorpc.v1.AggregationOptions.hint:type_name -> mongorpc.v1.IndexHint
	5,  // 72: mongorpc.v1.ProjectStage.FieldsEntry.value:type_name -> mongorpc.v1.ProjectExpression
	7,  // 73: mongorpc.v1.GroupStage.AccumulatorsEntry.value:type_name -> mongorpc.v1.Accumulator
	8,  // 74: mongorpc.v1.LookupStage.LetEntry.value:type_name -> mongorpc.v1.AggregationExpression
	8,  // 75: mongorpc.v1.AddFieldsStage.FieldsEntry.value:type_name -> mongorpc.v1.AggregationExpression
	25, // 76: mongorpc.v1.FacetStage.FacetsEntry.value:type_name -> mongorpc.v1.SubPipeline
	7,  // 77: mongorpc.v1.BucketStage.OutputEntry.value:type_name -> mongorpc.v1.Accumulator
	7,  // 78: mongorpc.v1.BucketAutoStage.OutputEntry.value:type_name -> mongorpc.v1.Accumulator
	79, // [79:79] is the sub-list for method output_type
	79, // [79:79] is the sub-list for method input_type
	79, // [79:79] is the sub-list for extension type_name
	79, // [79:79] is the sub-list for extension extendee
	0,  // [0:79] is the sub-list for field type_name
}

func init() { file_mongorpc_v1_aggregation_proto_init() }
func file_mongorpc_v1_aggregation_proto_init() {
	if File_mongorpc_v1_aggregation_proto != nil {
		return
	}
	file_mongorpc_v1_value_proto_init()
	file_mongorpc_v1_query_proto_init()
	file_mongorpc_v1_document_proto_init()
	file_mongorpc_v1_aggregation_proto_msgTypes[1].OneofWrappers = []any{
		(*PipelineStage_Match)(nil),
		(*PipelineStage_Project)(nil),
		(*PipelineStage_Group)(nil),
		(*PipelineStage_Sort)(nil),
		(*PipelineStage_Limit)(nil),
		(*PipelineStage_Skip)(nil),
		(*PipelineStage_Unwind)(nil),
		(*PipelineStage_Lookup)(nil),
		(*PipelineStage_AddFields)(nil),
		(*PipelineStage_Set)(nil),
		(*PipelineStage_Unset)(nil),
		(*PipelineStage_ReplaceRoot)(nil),
		(*PipelineStage_Count)(nil),
		(*PipelineStage_Facet)(nil),
		(*PipelineStage_Bucket)(nil),
		(*PipelineStage_BucketAuto)(nil),
		(*PipelineStage_Sample)(nil),
		(*PipelineStage_Out)(nil),
		(*PipelineStage_Merge)(nil),
		(*PipelineStage_GeoNear)(nil),
		(*PipelineStage_GraphLookup)(nil),
		(*PipelineStage_UnionWith)(nil),
		(*PipelineStage_Raw)(nil),
	}
	file_mongorpc_v1_aggregation_proto_msgTypes[4].OneofWrappers = []any{
		(*ProjectExpression_Include)(nil),
		(*ProjectExpression_Expression)(nil),
		(*ProjectExpression_Literal)(nil),
	}
	file_mongorpc_v1_aggregation_proto_msgTypes[7].OneofWrappers = []any{
		(*AggregationExpression_FieldRef)(nil),
		(*AggregationExpression_Literal)(nil),
		(*AggregationExpression_Variable)(nil),
		(*AggregationExpression_Operator)(nil),
		(*AggregationExpression_Conditional)(nil),
	}
	file_mongorpc_v1_aggregation_proto_msgTypes[9].OneofWrappers = []any{
		(*ConditionalExpression_Cond)(nil),
		(*ConditionalExpression_IfNull)(nil),
		(*ConditionalExpression_Switch)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_mongorpc_v1_aggregation_proto_rawDesc), len(file_mongorpc_v1_aggregation_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   41,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mongorpc_v1_aggregation_proto_goTypes,
		DependencyIndexes: file_mongorpc_v1_aggregation_proto_depIdxs,
		EnumInfos:         file_mongorpc_v1_aggregation_proto_enumTypes,
		MessageInfos:      file_mongorpc_v1_aggregation_proto_msgTypes,
	}.Build()
	File_mongorpc_v1_aggregation_proto = out.File
	file_mongorpc_v1_aggregation_proto_goTypes = nil
	file_mongorpc_v1_aggregation_proto_depIdxs = nil
}
